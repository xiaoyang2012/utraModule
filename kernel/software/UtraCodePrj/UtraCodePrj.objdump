
UtraCodePrj.elf:     file format elf32-littlenios2
UtraCodePrj.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x10020184

Program Header:
    LOAD off    0x00001000 vaddr 0x10020000 paddr 0x10020000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x10020020 paddr 0x10020020 align 2**12
         filesz 0x00001b40 memsz 0x00001b40 flags r-x
    LOAD off    0x00003000 vaddr 0x00000000 paddr 0x10021b60 align 2**12
         filesz 0x000001cc memsz 0x00000374 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  10020000  10020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000164  10020020  10020020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000019dc  10020184  10020184  00001184  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000068  00000000  10021b60  00003000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000164  00000068  10021bc8  00003068  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000001a8  000001cc  10021d2c  000031cc  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  000031cc  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000478  00000000  00000000  000031f0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000008d2  00000000  00000000  00003668  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00005f35  00000000  00000000  00003f3a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001f1b  00000000  00000000  00009e6f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000072b7  00000000  00000000  0000bd8a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  0000074c  00000000  00000000  00013044  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000014f6  00000000  00000000  00013790  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000144b  00000000  00000000  00014c86  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_macinfo 0008a439  00000000  00000000  000160d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000030  00000000  00000000  000a050c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000002a8  00000000  00000000  000a0540  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  000a22c4  2**0
                  CONTENTS, READONLY
 19 .cpu          00000005  00000000  00000000  000a22c7  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  000a22cc  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  000a22cd  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  000a22ce  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  000a22d2  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  000a22d6  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   00000009  00000000  00000000  000a22da  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    00000009  00000000  00000000  000a22e3  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   00000009  00000000  00000000  000a22ec  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000006  00000000  00000000  000a22f5  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000031  00000000  00000000  000a22fb  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     000d9bea  00000000  00000000  000a232c  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
10020000 l    d  .entry	00000000 .entry
10020020 l    d  .exceptions	00000000 .exceptions
10020184 l    d  .text	00000000 .text
00000000 l    d  .rodata	00000000 .rodata
00000068 l    d  .rwdata	00000000 .rwdata
000001cc l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
100201cc l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 UtraCode.c
10020270 l     F .text	0000002c initial
10020344 l     F .text	00000060 delayMs
1002029c l     F .text	0000001c usartInit
100202b8 l     F .text	0000008c dmaInit
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
00000068 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000148 l     O .rwdata	00000030 DMA_READ
00000178 l     O .rwdata	00000030 DMA_WRITE
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
100209e0 l     F .text	0000005c alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 alt_close.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
10021988 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 alt_exit.c
10020650 g     F .text	0000004c alt_main
100203a4 g     F .text	00000090 _puts_r
000001e8 g     O .bss	00000100 alt_irq
10021bc8 g       *ABS*	00000000 __flash_rwdata_start
100208d0 g     F .text	00000080 alt_avalon_sgdma_do_sync_transfer
10020a3c g     F .text	00000170 alt_avalon_sgdma_construct_descriptor_burst
000001b0 g     O .rwdata	00000004 jtag_uart
00000000  w      *UND*	00000000 __errno
10020000 g     F .entry	0000001c __reset
10020da4 g     F .text	000000dc alt_avalon_sgdma_construct_stream_to_mem_desc_burst
10020020 g       *ABS*	00000000 __flash_exceptions_start
000001d4 g     O .bss	00000004 errno
000001dc g     O .bss	00000004 alt_argv
000081a8 g       *ABS*	00000000 _gp
10021558 g     F .text	00000094 alt_find_dev
10021b60 g       *ABS*	00000000 __DTOR_END__
10020434 g     F .text	00000014 puts
10020fac g     F .text	00000138 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
000001b4 g     O .rwdata	00000004 uart1
00000000  w      *UND*	00000000 malloc
10021774 g     F .text	00000038 alt_icache_flush
1002089c g     F .text	0000001c alt_avalon_sgdma_stop
1002174c g     F .text	00000028 alt_dcache_flush
000001ac g     O .rwdata	00000004 _global_impure_ptr
00000374 g       *ABS*	00000000 __bss_end
10021694 g     F .text	00000088 alt_iic_isr_register
10020950 g     F .text	00000090 alt_avalon_sgdma_do_async_transfer
100215f8 g     F .text	00000018 alt_ic_irq_enabled
000001e4 g     O .bss	00000004 alt_irq_active
100200ec g     F .exceptions	00000098 alt_irq_handler
10020c18 g     F .text	00000034 alt_avalon_sgdma_check_descriptor_status
1002142c g     F .text	00000018 alt_dcache_flush_all
000001b8 g     O .rwdata	00000004 uart_test
000001cc g       *ABS*	00000000 __ram_rwdata_end
10020000 g       *ABS*	00000000 __alt_mem_onchip_memory
1002069c g     F .text	00000078 write
1002086c g     F .text	00000030 alt_avalon_sgdma_enable_desc_poll
00000068 g       *ABS*	00000000 __ram_rodata_end
100211f8 g     F .text	0000012c alt_avalon_sgdma_construct_mem_to_stream_desc
100207a8 g     F .text	00000010 alt_avalon_sgdma_register_callback
00000374 g       *ABS*	00000000 end
10021b5c g       *ABS*	00000000 __CTOR_LIST__
10000000 g       *ABS*	00000000 __alt_stack_pointer
1002084c g     F .text	00000020 alt_avalon_sgdma_disable_desc_poll
1002076c g     F .text	0000003c altera_avalon_jtag_uart_write
100210e4 g     F .text	00000114 alt_avalon_sgdma_construct_mem_to_mem_desc
10021324 g     F .text	000000c8 alt_avalon_sgdma_construct_stream_to_mem_desc
1002198c g     F .text	000001bc __call_exitprocs
10020184 g     F .text	0000004c _start
10020bac g     F .text	0000006c alt_avalon_sgdma_open
10020714 g     F .text	00000038 alt_sys_init
1002181c g     F .text	0000016c __register_exitproc
1002171c g     F .text	00000028 alt_remap_uncached
00000068 g       *ABS*	00000000 __ram_rwdata_start
00000000 g       *ABS*	00000000 __ram_rodata_start
100217e0 g     F .text	0000003c memcmp
00000374 g       *ABS*	00000000 __alt_stack_base
10021444 g     F .text	0000007c alt_dev_llist_insert
100208b8 g     F .text	00000018 alt_avalon_sgdma_start
10020468 g     F .text	000000bc __sfvwrite_small_dev
000001cc g       *ABS*	00000000 __bss_start
100201d0 g     F .text	000000a0 main
000001e0 g     O .bss	00000004 alt_envp
000001bc g     O .rwdata	00000008 alt_sgdma_list
000001cc g     O .bss	00000004 desc
000002e8 g     O .bss	0000008c _atexit0
000001c4 g     O .rwdata	00000004 alt_errno
10021b60 g       *ABS*	00000000 __CTOR_END__
10021b60 g       *ABS*	00000000 __flash_rodata_start
10021b60 g       *ABS*	00000000 __DTOR_LIST__
1002074c g     F .text	00000020 alt_irq_init
100217ac g     F .text	00000014 atexit
10020524 g     F .text	00000078 _write_r
000001a8 g     O .rwdata	00000004 _impure_ptr
000001d8 g     O .bss	00000004 alt_argc
1002150c g     F .text	0000004c _do_dtors
10020020 g       .exceptions	00000000 alt_irq_entry
10020020 g       *ABS*	00000000 __ram_exceptions_start
10021690 g     F .text	00000004 alt_ic_isr_register
000001cc g       *ABS*	00000000 _edata
00000374 g       *ABS*	00000000 _end
10020184 g       *ABS*	00000000 __ram_exceptions_end
10021650 g     F .text	00000040 alt_ic_irq_disable
10020c4c g     F .text	00000158 alt_avalon_sgdma_construct_descriptor
10021744 g     F .text	00000008 altera_nios2_qsys_irq_init
100217c0 g     F .text	00000020 exit
10000000 g       *ABS*	00000000 __alt_data_end
10020020 g     F .exceptions	00000000 alt_exception
000001d0 g     O .bss	00000004 sgdma_rx_dev
10021b48 g     F .text	00000014 _exit
10020448 g     F .text	00000020 strlen
100215ec g     F .text	0000000c alt_icache_flush_all
000001c8 g     O .rwdata	00000004 alt_priority_mask
10021610 g     F .text	00000040 alt_ic_irq_enable
10020e80 g     F .text	0000012c alt_avalon_sgdma_construct_mem_to_mem_desc_burst
00000000 g       *ABS*	00000000 __alt_mem_DDR3_MEM
100214c0 g     F .text	0000004c _do_ctors
100213ec g     F .text	00000040 close
1002059c g     F .text	000000b4 alt_load
100207b8 g     F .text	00000094 alt_avalon_sgdma_init
00000000  w      *UND*	00000000 free



Disassembly of section .entry:

10020000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
10020000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
10020004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
10020008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
1002000c:	00bffd16 	blt	zero,r2,10020004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
10020010:	004400b4 	movhi	at,4098
    ori r1, r1, %lo(_start)
10020014:	08406114 	ori	at,at,388
    jmp r1
10020018:	0800683a 	jmp	at
1002001c:	00000000 	call	10000000 <__alt_data_end>

Disassembly of section .exceptions:

10020020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
10020020:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
10020024:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
10020028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
1002002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
10020030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
10020034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
10020038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
1002003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
10020040:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
10020044:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
10020048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
1002004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
10020050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
10020054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
10020058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
1002005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
10020060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
10020064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
10020068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
1002006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
10020070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
10020074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
10020078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
1002007c:	10000326 	beq	r2,zero,1002008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
10020080:	20000226 	beq	r4,zero,1002008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
10020084:	00200ec0 	call	100200ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
10020088:	00000306 	br	10020098 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
1002008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
10020090:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
10020094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
10020098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
1002009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
100200a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
100200a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
100200a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
100200ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
100200b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
100200b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
100200b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
100200bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
100200c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
100200c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
100200c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
100200cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
100200d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
100200d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
100200d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
100200dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
100200e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
100200e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
100200e8:	ef80083a 	eret

100200ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
100200ec:	defffe04 	addi	sp,sp,-8
100200f0:	dfc00115 	stw	ra,4(sp)
100200f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
100200f8:	000b313a 	rdctl	r5,ipending
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
100200fc:	2880004c 	andi	r2,r5,1
10020100:	1005003a 	cmpeq	r2,r2,zero
10020104:	04000034 	movhi	r16,0
10020108:	84007a04 	addi	r16,r16,488
1002010c:	10001126 	beq	r2,zero,10020154 <alt_irq_handler+0x68>
10020110:	00c00044 	movi	r3,1
10020114:	0009883a 	mov	r4,zero
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
10020118:	18c7883a 	add	r3,r3,r3
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
1002011c:	28c4703a 	and	r2,r5,r3
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
      i++;
10020120:	21000044 	addi	r4,r4,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
10020124:	103ffc26 	beq	r2,zero,10020118 <alt_irq_handler+0x2c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
10020128:	200490fa 	slli	r2,r4,3
1002012c:	1405883a 	add	r2,r2,r16
10020130:	11000117 	ldw	r4,4(r2)
10020134:	10c00017 	ldw	r3,0(r2)
10020138:	183ee83a 	callr	r3
1002013c:	0005313a 	rdctl	r2,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
10020140:	10000c26 	beq	r2,zero,10020174 <alt_irq_handler+0x88>
10020144:	100b883a 	mov	r5,r2
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
10020148:	2880004c 	andi	r2,r5,1
1002014c:	1005003a 	cmpeq	r2,r2,zero
10020150:	103fef1e 	bne	r2,zero,10020110 <alt_irq_handler+0x24>
10020154:	0009883a 	mov	r4,zero
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
10020158:	200490fa 	slli	r2,r4,3
1002015c:	1405883a 	add	r2,r2,r16
10020160:	11000117 	ldw	r4,4(r2)
10020164:	10c00017 	ldw	r3,0(r2)
10020168:	183ee83a 	callr	r3
1002016c:	0005313a 	rdctl	r2,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
10020170:	103ff41e 	bne	r2,zero,10020144 <alt_irq_handler+0x58>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
10020174:	dfc00117 	ldw	ra,4(sp)
10020178:	dc000017 	ldw	r16,0(sp)
1002017c:	dec00204 	addi	sp,sp,8
10020180:	f800283a 	ret

Disassembly of section .text:

10020184 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
10020184:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
10020188:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
1002018c:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
10020190:	00bffd16 	blt	zero,r2,10020188 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
10020194:	06c40034 	movhi	sp,4096
    ori sp, sp, %lo(__alt_stack_pointer)
10020198:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
1002019c:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
100201a0:	d6a06a14 	ori	gp,gp,33192
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
100201a4:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
100201a8:	10807314 	ori	r2,r2,460

    movhi r3, %hi(__bss_end)
100201ac:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
100201b0:	18c0dd14 	ori	r3,r3,884

    beq r2, r3, 1f
100201b4:	10c00326 	beq	r2,r3,100201c4 <_start+0x40>

0:
    stw zero, (r2)
100201b8:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
100201bc:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
100201c0:	10fffd36 	bltu	r2,r3,100201b8 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
100201c4:	002059c0 	call	1002059c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
100201c8:	00206500 	call	10020650 <alt_main>

100201cc <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
100201cc:	003fff06 	br	100201cc <alt_after_alt_main>

100201d0 <main>:
//(2)配置ST_FIFO。
//（3）启动ST_FIFO完成dma发送。在这个过程中涵盖了sgdma_rx的基本使用


int main()
{
100201d0:	defffd04 	addi	sp,sp,-12
100201d4:	dfc00215 	stw	ra,8(sp)
100201d8:	df000115 	stw	fp,4(sp)
100201dc:	df000104 	addi	fp,sp,4
  alt_u8 ad_status = 0;
100201e0:	e03fff05 	stb	zero,-4(fp)
  initial();
100201e4:	00202700 	call	10020270 <initial>
  // LED
  IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE,0x01);
100201e8:	00c40134 	movhi	r3,4100
100201ec:	18c45004 	addi	r3,r3,4416
100201f0:	00800044 	movi	r2,1
100201f4:	18800035 	stwio	r2,0(r3)
  // AD参数：发送次数
  IOWR_ALTERA_AVALON_PIO_DATA(AD_CNT_BASE,(alt_u16)AD_SEND_COUNT);
100201f8:	00c40134 	movhi	r3,4100
100201fc:	18c44804 	addi	r3,r3,4384
10020200:	00804b04 	movi	r2,300
10020204:	18800035 	stwio	r2,0(r3)

  while(1)
  {
	  IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE,0x02);
10020208:	00c40134 	movhi	r3,4100
1002020c:	18c45004 	addi	r3,r3,4416
10020210:	00800084 	movi	r2,2
10020214:	18800035 	stwio	r2,0(r3)
	  //start send data
	  IOWR_ALTERA_AVALON_PIO_DATA(AD_CTRL_BASE,0x01);
10020218:	00c40134 	movhi	r3,4100
1002021c:	18c44404 	addi	r3,r3,4368
10020220:	00800044 	movi	r2,1
10020224:	18800035 	stwio	r2,0(r3)
	  while(ad_status == 0x00)
10020228:	00000606 	br	10020244 <main+0x74>
	  {
		  delayMs(100);
1002022c:	01001904 	movi	r4,100
10020230:	00203440 	call	10020344 <delayMs>
		  ad_status = IORD_ALTERA_AVALON_PIO_DATA(AD_STATUS_BASE);
10020234:	00840134 	movhi	r2,4100
10020238:	10844004 	addi	r2,r2,4352
1002023c:	10800037 	ldwio	r2,0(r2)
10020240:	e0bfff05 	stb	r2,-4(fp)
  while(1)
  {
	  IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE,0x02);
	  //start send data
	  IOWR_ALTERA_AVALON_PIO_DATA(AD_CTRL_BASE,0x01);
	  while(ad_status == 0x00)
10020244:	e0bfff03 	ldbu	r2,-4(fp)
10020248:	1005003a 	cmpeq	r2,r2,zero
1002024c:	103ff71e 	bne	r2,zero,1002022c <main+0x5c>
	  {
		  delayMs(100);
		  ad_status = IORD_ALTERA_AVALON_PIO_DATA(AD_STATUS_BASE);
	  }
	  IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE,0x03);
10020250:	00840134 	movhi	r2,4100
10020254:	10845004 	addi	r2,r2,4416
10020258:	00c000c4 	movi	r3,3
1002025c:	10c00035 	stwio	r3,0(r2)
	  //stop send data
	  IOWR_ALTERA_AVALON_PIO_DATA(AD_CTRL_BASE,0x00);
10020260:	00840134 	movhi	r2,4100
10020264:	10844404 	addi	r2,r2,4368
10020268:	10000035 	stwio	zero,0(r2)
  }
1002026c:	003fe606 	br	10020208 <main+0x38>

10020270 <initial>:

  return 0;
}

static void initial(void)
{
10020270:	defffe04 	addi	sp,sp,-8
10020274:	dfc00115 	stw	ra,4(sp)
10020278:	df000015 	stw	fp,0(sp)
1002027c:	d839883a 	mov	fp,sp
	//===initial=======
	usartInit();
10020280:	002029c0 	call	1002029c <usartInit>
	dmaInit();
10020284:	00202b80 	call	100202b8 <dmaInit>
}
10020288:	e037883a 	mov	sp,fp
1002028c:	dfc00117 	ldw	ra,4(sp)
10020290:	df000017 	ldw	fp,0(sp)
10020294:	dec00204 	addi	sp,sp,8
10020298:	f800283a 	ret

1002029c <usartInit>:

static void usartInit(void)
{
1002029c:	deffff04 	addi	sp,sp,-4
100202a0:	df000015 	stw	fp,0(sp)
100202a4:	d839883a 	mov	fp,sp

}
100202a8:	e037883a 	mov	sp,fp
100202ac:	df000017 	ldw	fp,0(sp)
100202b0:	dec00104 	addi	sp,sp,4
100202b4:	f800283a 	ret

100202b8 <dmaInit>:

static void dmaInit(void)
{
100202b8:	defffc04 	addi	sp,sp,-16
100202bc:	dfc00315 	stw	ra,12(sp)
100202c0:	df000215 	stw	fp,8(sp)
100202c4:	df000204 	addi	fp,sp,8
	int dma_code=0;
100202c8:	e03fff15 	stw	zero,-4(fp)
	//重定义desc DISCRIPTOR_MEMORY_BASE定义在system.h中，即descriptor_memory的基地址
	desc= (alt_sgdma_descriptor*)DISCRIPTOR_MEMORY_BASE;
100202cc:	008400f4 	movhi	r2,4099
100202d0:	108c0004 	addi	r2,r2,12288
100202d4:	d0a00915 	stw	r2,-32732(gp)

	//打开sgdma_rx
	sgdma_rx_dev= alt_avalon_sgdma_open("/dev/DMA_WRITE");
100202d8:	01000034 	movhi	r4,0
100202dc:	21000004 	addi	r4,r4,0
100202e0:	0020bac0 	call	10020bac <alt_avalon_sgdma_open>
100202e4:	d0a00a15 	stw	r2,-32728(gp)
	if(!sgdma_rx_dev)
100202e8:	d0a00a17 	ldw	r2,-32728(gp)
100202ec:	1004c03a 	cmpne	r2,r2,zero
100202f0:	1000041e 	bne	r2,zero,10020304 <dmaInit+0x4c>
	     {
	        printf("[triple_speed_ethernet_init] Error opening RX SGDMA\n");
100202f4:	01000034 	movhi	r4,0
100202f8:	21000404 	addi	r4,r4,16
100202fc:	00204340 	call	10020434 <puts>
	        return;
10020300:	00000b06 	br	10020330 <dmaInit+0x78>
	    }
	//==建立链表============
	//填充发送decriptor memory 并不需要自己填充，调用函数就好了。
	alt_avalon_sgdma_construct_stream_to_mem_desc(
10020304:	d1200917 	ldw	r4,-32732(gp)
10020308:	d0a00917 	ldw	r2,-32732(gp)
1002030c:	11400804 	addi	r5,r2,32
10020310:	d8000015 	stw	zero,0(sp)
10020314:	01880004 	movi	r6,8192
10020318:	000f883a 	mov	r7,zero
1002031c:	00213240 	call	10021324 <alt_avalon_sgdma_construct_stream_to_mem_desc>
		                       DMA_DESTINATION,
		                       0,				// 直到EOP
		                       0);

	   //启动sgdma_rx和sgdma_tx
	dma_code = alt_avalon_sgdma_do_async_transfer(sgdma_rx_dev,&desc[0]);
10020320:	d1200a17 	ldw	r4,-32728(gp)
10020324:	d1600917 	ldw	r5,-32732(gp)
10020328:	00209500 	call	10020950 <alt_avalon_sgdma_do_async_transfer>
1002032c:	e0bfff15 	stw	r2,-4(fp)

}
10020330:	e037883a 	mov	sp,fp
10020334:	dfc00117 	ldw	ra,4(sp)
10020338:	df000017 	ldw	fp,0(sp)
1002033c:	dec00204 	addi	sp,sp,8
10020340:	f800283a 	ret

10020344 <delayMs>:


static void delayMs(alt_u32 msec)
{
10020344:	defffc04 	addi	sp,sp,-16
10020348:	df000315 	stw	fp,12(sp)
1002034c:	df000304 	addi	fp,sp,12
10020350:	e13fff15 	stw	r4,-4(fp)
	alt_32 i,t;
	for(i=0;i<msec;i++)
10020354:	e03ffe15 	stw	zero,-8(fp)
10020358:	00000b06 	br	10020388 <delayMs+0x44>
		for(t=0;t<0xffff;t++);
1002035c:	e03ffd15 	stw	zero,-12(fp)
10020360:	00000306 	br	10020370 <delayMs+0x2c>
10020364:	e0bffd17 	ldw	r2,-12(fp)
10020368:	10800044 	addi	r2,r2,1
1002036c:	e0bffd15 	stw	r2,-12(fp)
10020370:	e0fffd17 	ldw	r3,-12(fp)
10020374:	00bfff94 	movui	r2,65534
10020378:	10fffa0e 	bge	r2,r3,10020364 <delayMs+0x20>


static void delayMs(alt_u32 msec)
{
	alt_32 i,t;
	for(i=0;i<msec;i++)
1002037c:	e0bffe17 	ldw	r2,-8(fp)
10020380:	10800044 	addi	r2,r2,1
10020384:	e0bffe15 	stw	r2,-8(fp)
10020388:	e0fffe17 	ldw	r3,-8(fp)
1002038c:	e0bfff17 	ldw	r2,-4(fp)
10020390:	18bff236 	bltu	r3,r2,1002035c <delayMs+0x18>
		for(t=0;t<0xffff;t++);
}
10020394:	e037883a 	mov	sp,fp
10020398:	df000017 	ldw	fp,0(sp)
1002039c:	dec00104 	addi	sp,sp,4
100203a0:	f800283a 	ret

100203a4 <_puts_r>:
100203a4:	defffd04 	addi	sp,sp,-12
100203a8:	dc000015 	stw	r16,0(sp)
100203ac:	2021883a 	mov	r16,r4
100203b0:	2809883a 	mov	r4,r5
100203b4:	dfc00215 	stw	ra,8(sp)
100203b8:	dc400115 	stw	r17,4(sp)
100203bc:	2823883a 	mov	r17,r5
100203c0:	00204480 	call	10020448 <strlen>
100203c4:	80c00217 	ldw	r3,8(r16)
100203c8:	020400b4 	movhi	r8,4098
100203cc:	42011a04 	addi	r8,r8,1128
100203d0:	880d883a 	mov	r6,r17
100203d4:	100f883a 	mov	r7,r2
100203d8:	8009883a 	mov	r4,r16
100203dc:	180b883a 	mov	r5,r3
100203e0:	1a000115 	stw	r8,4(r3)
100203e4:	403ee83a 	callr	r8
100203e8:	047fffc4 	movi	r17,-1
100203ec:	8009883a 	mov	r4,r16
100203f0:	01800034 	movhi	r6,0
100203f4:	31801104 	addi	r6,r6,68
100203f8:	01c00044 	movi	r7,1
100203fc:	1440071e 	bne	r2,r17,1002041c <_puts_r+0x78>
10020400:	00ffffc4 	movi	r3,-1
10020404:	1805883a 	mov	r2,r3
10020408:	dfc00217 	ldw	ra,8(sp)
1002040c:	dc400117 	ldw	r17,4(sp)
10020410:	dc000017 	ldw	r16,0(sp)
10020414:	dec00304 	addi	sp,sp,12
10020418:	f800283a 	ret
1002041c:	81400217 	ldw	r5,8(r16)
10020420:	28c00117 	ldw	r3,4(r5)
10020424:	183ee83a 	callr	r3
10020428:	0007883a 	mov	r3,zero
1002042c:	147ff51e 	bne	r2,r17,10020404 <_puts_r+0x60>
10020430:	003ff306 	br	10020400 <_puts_r+0x5c>

10020434 <puts>:
10020434:	00800034 	movhi	r2,0
10020438:	10806a04 	addi	r2,r2,424
1002043c:	200b883a 	mov	r5,r4
10020440:	11000017 	ldw	r4,0(r2)
10020444:	00203a41 	jmpi	100203a4 <_puts_r>

10020448 <strlen>:
10020448:	20800007 	ldb	r2,0(r4)
1002044c:	10000526 	beq	r2,zero,10020464 <strlen+0x1c>
10020450:	2007883a 	mov	r3,r4
10020454:	18c00044 	addi	r3,r3,1
10020458:	18800007 	ldb	r2,0(r3)
1002045c:	103ffd1e 	bne	r2,zero,10020454 <strlen+0xc>
10020460:	1905c83a 	sub	r2,r3,r4
10020464:	f800283a 	ret

10020468 <__sfvwrite_small_dev>:
10020468:	2880000b 	ldhu	r2,0(r5)
1002046c:	defffa04 	addi	sp,sp,-24
10020470:	dcc00315 	stw	r19,12(sp)
10020474:	1080020c 	andi	r2,r2,8
10020478:	dc800215 	stw	r18,8(sp)
1002047c:	dc400115 	stw	r17,4(sp)
10020480:	dfc00515 	stw	ra,20(sp)
10020484:	dd000415 	stw	r20,16(sp)
10020488:	dc000015 	stw	r16,0(sp)
1002048c:	2825883a 	mov	r18,r5
10020490:	2027883a 	mov	r19,r4
10020494:	3023883a 	mov	r17,r6
10020498:	10002026 	beq	r2,zero,1002051c <__sfvwrite_small_dev+0xb4>
1002049c:	2940008f 	ldh	r5,2(r5)
100204a0:	28000f16 	blt	r5,zero,100204e0 <__sfvwrite_small_dev+0x78>
100204a4:	01c01b0e 	bge	zero,r7,10020514 <__sfvwrite_small_dev+0xac>
100204a8:	3821883a 	mov	r16,r7
100204ac:	05010004 	movi	r20,1024
100204b0:	00000206 	br	100204bc <__sfvwrite_small_dev+0x54>
100204b4:	0400170e 	bge	zero,r16,10020514 <__sfvwrite_small_dev+0xac>
100204b8:	9140008f 	ldh	r5,2(r18)
100204bc:	880d883a 	mov	r6,r17
100204c0:	9809883a 	mov	r4,r19
100204c4:	800f883a 	mov	r7,r16
100204c8:	a400010e 	bge	r20,r16,100204d0 <__sfvwrite_small_dev+0x68>
100204cc:	01c10004 	movi	r7,1024
100204d0:	00205240 	call	10020524 <_write_r>
100204d4:	88a3883a 	add	r17,r17,r2
100204d8:	80a1c83a 	sub	r16,r16,r2
100204dc:	00bff516 	blt	zero,r2,100204b4 <__sfvwrite_small_dev+0x4c>
100204e0:	9080000b 	ldhu	r2,0(r18)
100204e4:	00ffffc4 	movi	r3,-1
100204e8:	10801014 	ori	r2,r2,64
100204ec:	9080000d 	sth	r2,0(r18)
100204f0:	1805883a 	mov	r2,r3
100204f4:	dfc00517 	ldw	ra,20(sp)
100204f8:	dd000417 	ldw	r20,16(sp)
100204fc:	dcc00317 	ldw	r19,12(sp)
10020500:	dc800217 	ldw	r18,8(sp)
10020504:	dc400117 	ldw	r17,4(sp)
10020508:	dc000017 	ldw	r16,0(sp)
1002050c:	dec00604 	addi	sp,sp,24
10020510:	f800283a 	ret
10020514:	0007883a 	mov	r3,zero
10020518:	003ff506 	br	100204f0 <__sfvwrite_small_dev+0x88>
1002051c:	00ffffc4 	movi	r3,-1
10020520:	003ff306 	br	100204f0 <__sfvwrite_small_dev+0x88>

10020524 <_write_r>:
10020524:	defffd04 	addi	sp,sp,-12
10020528:	dc000015 	stw	r16,0(sp)
1002052c:	04000034 	movhi	r16,0
10020530:	84007504 	addi	r16,r16,468
10020534:	dc400115 	stw	r17,4(sp)
10020538:	80000015 	stw	zero,0(r16)
1002053c:	2023883a 	mov	r17,r4
10020540:	2809883a 	mov	r4,r5
10020544:	300b883a 	mov	r5,r6
10020548:	380d883a 	mov	r6,r7
1002054c:	dfc00215 	stw	ra,8(sp)
10020550:	002069c0 	call	1002069c <write>
10020554:	1007883a 	mov	r3,r2
10020558:	00bfffc4 	movi	r2,-1
1002055c:	18800626 	beq	r3,r2,10020578 <_write_r+0x54>
10020560:	1805883a 	mov	r2,r3
10020564:	dfc00217 	ldw	ra,8(sp)
10020568:	dc400117 	ldw	r17,4(sp)
1002056c:	dc000017 	ldw	r16,0(sp)
10020570:	dec00304 	addi	sp,sp,12
10020574:	f800283a 	ret
10020578:	80800017 	ldw	r2,0(r16)
1002057c:	103ff826 	beq	r2,zero,10020560 <_write_r+0x3c>
10020580:	88800015 	stw	r2,0(r17)
10020584:	1805883a 	mov	r2,r3
10020588:	dfc00217 	ldw	ra,8(sp)
1002058c:	dc400117 	ldw	r17,4(sp)
10020590:	dc000017 	ldw	r16,0(sp)
10020594:	dec00304 	addi	sp,sp,12
10020598:	f800283a 	ret

1002059c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
1002059c:	deffff04 	addi	sp,sp,-4
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
100205a0:	010400b4 	movhi	r4,4098
100205a4:	2106f204 	addi	r4,r4,7112
100205a8:	00c00034 	movhi	r3,0
100205ac:	18c01a04 	addi	r3,r3,104
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
100205b0:	dfc00015 	stw	ra,0(sp)

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
100205b4:	20c00826 	beq	r4,r3,100205d8 <alt_load+0x3c>
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
100205b8:	01400034 	movhi	r5,0
100205bc:	29407304 	addi	r5,r5,460
  {
    while( to != end )
100205c0:	19400526 	beq	r3,r5,100205d8 <alt_load+0x3c>
    {
      *to++ = *from++;
100205c4:	20800017 	ldw	r2,0(r4)
100205c8:	21000104 	addi	r4,r4,4
100205cc:	18800015 	stw	r2,0(r3)
100205d0:	18c00104 	addi	r3,r3,4
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
100205d4:	28fffb1e 	bne	r5,r3,100205c4 <alt_load+0x28>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
100205d8:	010400b4 	movhi	r4,4098
100205dc:	21000804 	addi	r4,r4,32
100205e0:	00c400b4 	movhi	r3,4098
100205e4:	18c00804 	addi	r3,r3,32

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
100205e8:	20c00826 	beq	r4,r3,1002060c <alt_load+0x70>
100205ec:	014400b4 	movhi	r5,4098
100205f0:	29406104 	addi	r5,r5,388
  {
    while( to != end )
100205f4:	19400526 	beq	r3,r5,1002060c <alt_load+0x70>
    {
      *to++ = *from++;
100205f8:	20800017 	ldw	r2,0(r4)
100205fc:	21000104 	addi	r4,r4,4
10020600:	18800015 	stw	r2,0(r3)
10020604:	18c00104 	addi	r3,r3,4
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
10020608:	28fffb1e 	bne	r5,r3,100205f8 <alt_load+0x5c>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
1002060c:	010400b4 	movhi	r4,4098
10020610:	2106d804 	addi	r4,r4,7008
10020614:	00c00034 	movhi	r3,0
10020618:	18c00004 	addi	r3,r3,0

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
1002061c:	20c00826 	beq	r4,r3,10020640 <alt_load+0xa4>
10020620:	01400034 	movhi	r5,0
10020624:	29401a04 	addi	r5,r5,104
  {
    while( to != end )
10020628:	19400526 	beq	r3,r5,10020640 <alt_load+0xa4>
    {
      *to++ = *from++;
1002062c:	20800017 	ldw	r2,0(r4)
10020630:	21000104 	addi	r4,r4,4
10020634:	18800015 	stw	r2,0(r3)
10020638:	18c00104 	addi	r3,r3,4
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
1002063c:	28fffb1e 	bne	r5,r3,1002062c <alt_load+0x90>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
10020640:	002142c0 	call	1002142c <alt_dcache_flush_all>
  alt_icache_flush_all();
}
10020644:	dfc00017 	ldw	ra,0(sp)
10020648:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
1002064c:	00215ec1 	jmpi	100215ec <alt_icache_flush_all>

10020650 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10020650:	defffe04 	addi	sp,sp,-8
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10020654:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10020658:	dfc00115 	stw	ra,4(sp)
1002065c:	dc400015 	stw	r17,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10020660:	002074c0 	call	1002074c <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
10020664:	00207140 	call	10020714 <alt_sys_init>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
10020668:	00214c00 	call	100214c0 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
1002066c:	010400b4 	movhi	r4,4098
10020670:	21054304 	addi	r4,r4,5388
10020674:	00217ac0 	call	100217ac <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
10020678:	d1200c17 	ldw	r4,-32720(gp)
1002067c:	d1600d17 	ldw	r5,-32716(gp)
10020680:	d1a00e17 	ldw	r6,-32712(gp)
10020684:	00201d00 	call	100201d0 <main>
10020688:	1023883a 	mov	r17,r2
  close(STDOUT_FILENO);
1002068c:	01000044 	movi	r4,1
10020690:	00213ec0 	call	100213ec <close>
  exit (result);
10020694:	8809883a 	mov	r4,r17
10020698:	00217c00 	call	100217c0 <exit>

1002069c <write>:
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
1002069c:	deffff04 	addi	sp,sp,-4
100206a0:	2007883a 	mov	r3,r4
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
100206a4:	00800044 	movi	r2,1
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
100206a8:	dfc00015 	stw	ra,0(sp)
#endif

    switch (file) {
#ifdef ALT_STDOUT_PRESENT
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
100206ac:	000f883a 	mov	r7,zero
100206b0:	01000034 	movhi	r4,0
100206b4:	21006c04 	addi	r4,r4,432
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
100206b8:	18801326 	beq	r3,r2,10020708 <write+0x6c>
100206bc:	00800084 	movi	r2,2
100206c0:	18800e26 	beq	r3,r2,100206fc <write+0x60>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
100206c4:	00800034 	movhi	r2,0
100206c8:	10807104 	addi	r2,r2,452
100206cc:	10800017 	ldw	r2,0(r2)
100206d0:	00c00034 	movhi	r3,0
100206d4:	18c07504 	addi	r3,r3,468
100206d8:	10000226 	beq	r2,zero,100206e4 <write+0x48>
100206dc:	103ee83a 	callr	r2
100206e0:	1007883a 	mov	r3,r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
100206e4:	00801444 	movi	r2,81
100206e8:	18800015 	stw	r2,0(r3)
        return -1;
    }
}
100206ec:	00bfffc4 	movi	r2,-1
100206f0:	dfc00017 	ldw	ra,0(sp)
100206f4:	dec00104 	addi	sp,sp,4
100206f8:	f800283a 	ret
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
100206fc:	01000034 	movhi	r4,0
10020700:	21006c04 	addi	r4,r4,432
10020704:	000f883a 	mov	r7,zero
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
        return -1;
    }
}
10020708:	dfc00017 	ldw	ra,0(sp)
1002070c:	dec00104 	addi	sp,sp,4
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
10020710:	002076c1 	jmpi	1002076c <altera_avalon_jtag_uart_write>

10020714 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
10020714:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( DMA_READ, DMA_READ);
10020718:	01000034 	movhi	r4,0
1002071c:	21005204 	addi	r4,r4,328
10020720:	000b883a 	mov	r5,zero
10020724:	01800084 	movi	r6,2
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
10020728:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( DMA_READ, DMA_READ);
1002072c:	00207b80 	call	100207b8 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( DMA_WRITE, DMA_WRITE);
10020730:	01000034 	movhi	r4,0
10020734:	21005e04 	addi	r4,r4,376
10020738:	000b883a 	mov	r5,zero
1002073c:	01800044 	movi	r6,1
    ALTERA_AVALON_SPI_INIT ( SPI1, spi1);
    ALTERA_AVALON_SPI_INIT ( SPI2, spi2);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
    ALTERA_AVALON_UART_INIT ( UART1, uart1);
    ALTERA_AVALON_UART_INIT ( UART_TEST, uart_test);
}
10020740:	dfc00017 	ldw	ra,0(sp)
10020744:	dec00104 	addi	sp,sp,4

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( DMA_READ, DMA_READ);
    ALTERA_AVALON_SGDMA_INIT ( DMA_WRITE, DMA_WRITE);
10020748:	00207b81 	jmpi	100207b8 <alt_avalon_sgdma_init>

1002074c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
1002074c:	deffff04 	addi	sp,sp,-4
10020750:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2, nios2);
10020754:	00217440 	call	10021744 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
10020758:	00800044 	movi	r2,1
1002075c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
10020760:	dfc00017 	ldw	ra,0(sp)
10020764:	dec00104 	addi	sp,sp,4
10020768:	f800283a 	ret

1002076c <altera_avalon_jtag_uart_write>:
int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;
1002076c:	314f883a 	add	r7,r6,r5
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
10020770:	21000017 	ldw	r4,0(r4)

  const char * end = ptr + count;

  while (ptr < end)
10020774:	29c0052e 	bgeu	r5,r7,1002078c <altera_avalon_jtag_uart_write+0x20>
10020778:	20c00104 	addi	r3,r4,4
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
1002077c:	18800037 	ldwio	r2,0(r3)
10020780:	10bfffec 	andhi	r2,r2,65535
10020784:	1000031e 	bne	r2,zero,10020794 <altera_avalon_jtag_uart_write+0x28>
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
10020788:	29fffc36 	bltu	r5,r7,1002077c <altera_avalon_jtag_uart_write+0x10>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
}
1002078c:	3005883a 	mov	r2,r6
10020790:	f800283a 	ret

  const char * end = ptr + count;

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
10020794:	28800007 	ldb	r2,0(r5)
10020798:	29400044 	addi	r5,r5,1
1002079c:	20800035 	stwio	r2,0(r4)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
100207a0:	29fff636 	bltu	r5,r7,1002077c <altera_avalon_jtag_uart_write+0x10>
100207a4:	003ff906 	br	1002078c <altera_avalon_jtag_uart_write+0x20>

100207a8 <alt_avalon_sgdma_register_callback>:
  alt_u32 chain_control,
  void *context)
{
  dev->callback         = callback;
  dev->callback_context = context;
  dev->chain_control    = chain_control;
100207a8:	21800b15 	stw	r6,44(r4)
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
  dev->callback         = callback;
100207ac:	21400915 	stw	r5,36(r4)
  dev->callback_context = context;
100207b0:	21c00a15 	stw	r7,40(r4)
  dev->chain_control    = chain_control;
}
100207b4:	f800283a 	ret

100207b8 <alt_avalon_sgdma_init>:

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
100207b8:	20c00317 	ldw	r3,12(r4)
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
100207bc:	defffb04 	addi	sp,sp,-20

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
100207c0:	01c00404 	movi	r7,16
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
100207c4:	dd400315 	stw	r21,12(sp)
100207c8:	dcc00215 	stw	r19,8(sp)
100207cc:	dc400115 	stw	r17,4(sp)
100207d0:	282b883a 	mov	r21,r5
100207d4:	2023883a 	mov	r17,r4

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
100207d8:	19c7883a 	add	r3,r3,r7
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
100207dc:	3027883a 	mov	r19,r6

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
100207e0:	01400074 	movhi	r5,1
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
100207e4:	dfc00415 	stw	ra,16(sp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
100207e8:	19400035 	stwio	r5,0(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
100207ec:	20800317 	ldw	r2,12(r4)
100207f0:	11c5883a 	add	r2,r2,r7
100207f4:	11400035 	stwio	r5,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
100207f8:	20c00317 	ldw	r3,12(r4)
100207fc:	19c7883a 	add	r3,r3,r7
10020800:	18000035 	stwio	zero,0(r3)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
10020804:	21400317 	ldw	r5,12(r4)
10020808:	00803fc4 	movi	r2,255
1002080c:	28800035 	stwio	r2,0(r5)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
10020810:	d1600504 	addi	r5,gp,-32748
10020814:	00214440 	call	10021444 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
10020818:	880f883a 	mov	r7,r17
1002081c:	a809883a 	mov	r4,r21
10020820:	980b883a 	mov	r5,r19
10020824:	018400b4 	movhi	r6,4098
10020828:	31827804 	addi	r6,r6,2528
1002082c:	d8000015 	stw	zero,0(sp)
10020830:	00216900 	call	10021690 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
10020834:	dfc00417 	ldw	ra,16(sp)
10020838:	dd400317 	ldw	r21,12(sp)
1002083c:	dcc00217 	ldw	r19,8(sp)
10020840:	dc400117 	ldw	r17,4(sp)
10020844:	dec00504 	addi	sp,sp,20
10020848:	f800283a 	ret

1002084c <alt_avalon_sgdma_disable_desc_poll>:
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
1002084c:	20800317 	ldw	r2,12(r4)
10020850:	10800404 	addi	r2,r2,16
10020854:	10c00037 	ldwio	r3,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
10020858:	013fff34 	movhi	r4,65532
1002085c:	213fffc4 	addi	r4,r4,-1
10020860:	1906703a 	and	r3,r3,r4
10020864:	10c00035 	stwio	r3,0(r2)
  
  return;
}
10020868:	f800283a 	ret

1002086c <alt_avalon_sgdma_enable_desc_poll>:
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
1002086c:	21800317 	ldw	r6,12(r4)
10020870:	31800404 	addi	r6,r6,16
10020874:	30c00037 	ldwio	r3,0(r6)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
10020878:	00a00434 	movhi	r2,32784
1002087c:	10bfffc4 	addi	r2,r2,-1
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
10020880:	280a953a 	slli	r5,r5,20
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
10020884:	1886703a 	and	r3,r3,r2
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
10020888:	295ffc2c 	andhi	r5,r5,32752
1002088c:	29400134 	orhi	r5,r5,4
10020890:	1946b03a 	or	r3,r3,r5
10020894:	30c00035 	stwio	r3,0(r6)
  
  return;
}
10020898:	f800283a 	ret

1002089c <alt_avalon_sgdma_stop>:
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
1002089c:	20800317 	ldw	r2,12(r4)
100208a0:	10800404 	addi	r2,r2,16
100208a4:	10c00037 	ldwio	r3,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
100208a8:	013ff7c4 	movi	r4,-33
100208ac:	1906703a 	and	r3,r3,r4
100208b0:	10c00035 	stwio	r3,0(r2)
}
100208b4:	f800283a 	ret

100208b8 <alt_avalon_sgdma_start>:
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
100208b8:	20c00317 	ldw	r3,12(r4)
100208bc:	18c00404 	addi	r3,r3,16
100208c0:	18800037 	ldwio	r2,0(r3)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
100208c4:	10800814 	ori	r2,r2,32
100208c8:	18800035 	stwio	r2,0(r3)
}
100208cc:	f800283a 	ret

100208d0 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
100208d0:	200d883a 	mov	r6,r4
100208d4:	21000317 	ldw	r4,12(r4)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
100208d8:	20800037 	ldwio	r2,0(r4)
100208dc:	1080040c 	andi	r2,r2,16
100208e0:	103ffd1e 	bne	r2,zero,100208d8 <alt_avalon_sgdma_do_sync_transfer+0x8>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
100208e4:	20800437 	ldwio	r2,16(r4)
100208e8:	00fff7c4 	movi	r3,-33
100208ec:	10c4703a 	and	r2,r2,r3
100208f0:	20800435 	stwio	r2,16(r4)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
100208f4:	31000317 	ldw	r4,12(r6)
100208f8:	00803fc4 	movi	r2,255
100208fc:	20800035 	stwio	r2,0(r4)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
10020900:	30c00317 	ldw	r3,12(r6)
10020904:	19400835 	stwio	r5,32(r3)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
10020908:	31000317 	ldw	r4,12(r6)
1002090c:	20800437 	ldwio	r2,16(r4)
10020910:	10801814 	ori	r2,r2,96
10020914:	20800435 	stwio	r2,16(r4)
10020918:	31000317 	ldw	r4,12(r6)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
1002091c:	20800037 	ldwio	r2,0(r4)
10020920:	1080040c 	andi	r2,r2,16
10020924:	103ffd1e 	bne	r2,zero,1002091c <alt_avalon_sgdma_do_sync_transfer+0x4c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
10020928:	20800437 	ldwio	r2,16(r4)
1002092c:	00fff7c4 	movi	r3,-33
10020930:	10c4703a 	and	r2,r2,r3
10020934:	20800435 	stwio	r2,16(r4)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
10020938:	31000317 	ldw	r4,12(r6)
1002093c:	20800037 	ldwio	r2,0(r4)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
10020940:	00c03fc4 	movi	r3,255
10020944:	20c00035 	stwio	r3,0(r4)

  return status;
}
10020948:	10803fcc 	andi	r2,r2,255
1002094c:	f800283a 	ret

10020950 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
10020950:	200d883a 	mov	r6,r4
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
10020954:	21000317 	ldw	r4,12(r4)
10020958:	20800037 	ldwio	r2,0(r4)
1002095c:	00fffc04 	movi	r3,-16
10020960:	1080040c 	andi	r2,r2,16
10020964:	10000226 	beq	r2,zero,10020970 <alt_avalon_sgdma_do_async_transfer+0x20>
  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
}
10020968:	1805883a 	mov	r2,r3
1002096c:	f800283a 	ret
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
10020970:	20800437 	ldwio	r2,16(r4)
10020974:	00fff7c4 	movi	r3,-33
10020978:	10c4703a 	and	r2,r2,r3
1002097c:	20800435 	stwio	r2,16(r4)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
10020980:	31000317 	ldw	r4,12(r6)
10020984:	00803fc4 	movi	r2,255
10020988:	20800035 	stwio	r2,0(r4)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
1002098c:	30c00317 	ldw	r3,12(r6)
10020990:	19400835 	stwio	r5,32(r3)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
10020994:	30800917 	ldw	r2,36(r6)
10020998:	10000926 	beq	r2,zero,100209c0 <alt_avalon_sgdma_do_async_transfer+0x70>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
1002099c:	31000317 	ldw	r4,12(r6)
100209a0:	20c00437 	ldwio	r3,16(r4)

    control |= (dev->chain_control                          |
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
100209a4:	30800b17 	ldw	r2,44(r6)
100209a8:	10801814 	ori	r2,r2,96
100209ac:	1886b03a 	or	r3,r3,r2
100209b0:	20c00435 	stwio	r3,16(r4)
100209b4:	0007883a 	mov	r3,zero
  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
}
100209b8:	1805883a 	mov	r2,r3
100209bc:	f800283a 	ret
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
100209c0:	30800317 	ldw	r2,12(r6)
100209c4:	10c00437 	ldwio	r3,16(r2)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
100209c8:	013ffbc4 	movi	r4,-17
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
100209cc:	18c01814 	ori	r3,r3,96
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
100209d0:	1906703a 	and	r3,r3,r4
100209d4:	10c00435 	stwio	r3,16(r2)
100209d8:	0007883a 	mov	r3,zero
100209dc:	003fe206 	br	10020968 <alt_avalon_sgdma_do_async_transfer+0x18>

100209e0 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
100209e0:	200b883a 	mov	r5,r4
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
100209e4:	21000317 	ldw	r4,12(r4)
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
100209e8:	defffe04 	addi	sp,sp,-8
100209ec:	dfc00115 	stw	ra,4(sp)
100209f0:	dc000015 	stw	r16,0(sp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
100209f4:	20800437 	ldwio	r2,16(r4)
100209f8:	10a00034 	orhi	r2,r2,32768
100209fc:	20800435 	stwio	r2,16(r4)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
10020a00:	28c00317 	ldw	r3,12(r5)
10020a04:	18800437 	ldwio	r2,16(r3)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
10020a08:	28c00917 	ldw	r3,36(r5)
10020a0c:	18000726 	beq	r3,zero,10020a2c <alt_avalon_sgdma_irq+0x4c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10020a10:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10020a14:	00bfff84 	movi	r2,-2
10020a18:	8084703a 	and	r2,r16,r2
10020a1c:	1001703a 	wrctl	status,r2
    cpu_sr = alt_irq_disable_all();
    (dev->callback)(dev->callback_context);
10020a20:	29000a17 	ldw	r4,40(r5)
10020a24:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10020a28:	8001703a 	wrctl	status,r16
    alt_irq_enable_all(cpu_sr);
  }
}
10020a2c:	dfc00117 	ldw	ra,4(sp)
10020a30:	dc000017 	ldw	r16,0(sp)
10020a34:	dec00204 	addi	sp,sp,8
10020a38:	f800283a 	ret

10020a3c <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
10020a3c:	defff604 	addi	sp,sp,-40
10020a40:	ddc00815 	stw	r23,32(sp)
10020a44:	dd800715 	stw	r22,28(sp)
10020a48:	dd400615 	stw	r21,24(sp)
10020a4c:	df000915 	stw	fp,36(sp)
10020a50:	dd000515 	stw	r20,20(sp)
10020a54:	dcc00415 	stw	r19,16(sp)
10020a58:	dc800315 	stw	r18,12(sp)
10020a5c:	dc400215 	stw	r17,8(sp)
10020a60:	dc000115 	stw	r16,4(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020a64:	288007c3 	ldbu	r2,31(r5)
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
10020a68:	d8c00b17 	ldw	r3,44(sp)
10020a6c:	da000c17 	ldw	r8,48(sp)
10020a70:	da400d17 	ldw	r9,52(sp)
10020a74:	dd400e17 	ldw	r21,56(sp)
10020a78:	dd800f17 	ldw	r22,60(sp)
10020a7c:	da800a0b 	ldhu	r10,40(sp)
10020a80:	dac01003 	ldbu	r11,64(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020a84:	10801fcc 	andi	r2,r2,127
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
10020a88:	202f883a 	mov	r23,r4
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020a8c:	288007e5 	stbio	r2,31(r5)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020a90:	3022d63a 	srli	r17,r6,24
  desc->write_addr               = write_addr;
10020a94:	3824d63a 	srli	r18,r7,24
  desc->next                     = (alt_u32 *) next;
10020a98:	2826d63a 	srli	r19,r5,24
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10020a9c:	5028d23a 	srli	r20,r10,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020aa0:	3008d23a 	srli	r4,r6,8
10020aa4:	3018d43a 	srli	r12,r6,16
  desc->write_addr               = write_addr;
10020aa8:	381ad23a 	srli	r13,r7,8
10020aac:	381cd43a 	srli	r14,r7,16
  desc->next                     = (alt_u32 *) next;
10020ab0:	281ed23a 	srli	r15,r5,8
10020ab4:	2820d43a 	srli	r16,r5,16
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020ab8:	d8000005 	stb	zero,0(sp)
10020abc:	00bfe044 	movi	r2,-127
10020ac0:	1807003a 	cmpeq	r3,r3,zero
10020ac4:	4010c03a 	cmpne	r8,r8,zero
10020ac8:	4812c03a 	cmpne	r9,r9,zero
10020acc:	10c7c83a 	sub	r3,r2,r3
10020ad0:	5f0003cc 	andi	fp,r11,15
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020ad4:	b9000045 	stb	r4,1(r23)
10020ad8:	bb000085 	stb	r12,2(r23)
10020adc:	bc4000c5 	stb	r17,3(r23)
  desc->write_addr               = write_addr;
10020ae0:	bb400245 	stb	r13,9(r23)
10020ae4:	bb800285 	stb	r14,10(r23)
10020ae8:	bc8002c5 	stb	r18,11(r23)
  desc->next                     = (alt_u32 *) next;
10020aec:	bbc00445 	stb	r15,17(r23)
10020af0:	bc000485 	stb	r16,18(r23)
10020af4:	bcc004c5 	stb	r19,19(r23)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10020af8:	bd000645 	stb	r20,25(r23)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
10020afc:	bd400685 	stb	r21,26(r23)
  desc->write_burst              = write_burst;
10020b00:	bd8006c5 	stb	r22,27(r23)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020b04:	4211883a 	add	r8,r8,r8
10020b08:	480490ba 	slli	r2,r9,2
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020b0c:	b9800005 	stb	r6,0(r23)
  desc->write_addr               = write_addr;
10020b10:	b9c00205 	stb	r7,8(r23)
  desc->next                     = (alt_u32 *) next;
10020b14:	b9400405 	stb	r5,16(r23)
  desc->read_addr_pad            = 0x0;
10020b18:	b8000105 	stb	zero,4(r23)
10020b1c:	b8000145 	stb	zero,5(r23)
10020b20:	b8000185 	stb	zero,6(r23)
10020b24:	b80001c5 	stb	zero,7(r23)
  desc->write_addr_pad           = 0x0;
10020b28:	b8000305 	stb	zero,12(r23)
10020b2c:	b8000345 	stb	zero,13(r23)
10020b30:	b8000385 	stb	zero,14(r23)
10020b34:	b80003c5 	stb	zero,15(r23)
  desc->next_pad                 = 0x0;
10020b38:	b8000505 	stb	zero,20(r23)
10020b3c:	b8000545 	stb	zero,21(r23)
10020b40:	b8000585 	stb	zero,22(r23)
10020b44:	b80005c5 	stb	zero,23(r23)
  desc->bytes_to_transfer        = length_or_eop;
10020b48:	ba800605 	stb	r10,24(r23)
  desc->actual_bytes_transferred = 0;
10020b4c:	b8000705 	stb	zero,28(r23)
10020b50:	b8000745 	stb	zero,29(r23)
  desc->status                   = 0x0;
10020b54:	b8000785 	stb	zero,30(r23)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020b58:	58000226 	beq	r11,zero,10020b64 <alt_avalon_sgdma_construct_descriptor_burst+0x128>
10020b5c:	e03890fa 	slli	fp,fp,3
10020b60:	df000005 	stb	fp,0(sp)
10020b64:	d9000003 	ldbu	r4,0(sp)
10020b68:	4084b03a 	or	r2,r8,r2
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10020b6c:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020b70:	1906b03a 	or	r3,r3,r4
10020b74:	10c4b03a 	or	r2,r2,r3
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10020b78:	b809883a 	mov	r4,r23
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020b7c:	b88007c5 	stb	r2,31(r23)
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
}
10020b80:	df000917 	ldw	fp,36(sp)
10020b84:	ddc00817 	ldw	r23,32(sp)
10020b88:	dd800717 	ldw	r22,28(sp)
10020b8c:	dd400617 	ldw	r21,24(sp)
10020b90:	dd000517 	ldw	r20,20(sp)
10020b94:	dcc00417 	ldw	r19,16(sp)
10020b98:	dc800317 	ldw	r18,12(sp)
10020b9c:	dc400217 	ldw	r17,8(sp)
10020ba0:	dc000117 	ldw	r16,4(sp)
10020ba4:	dec00a04 	addi	sp,sp,40
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10020ba8:	002171c1 	jmpi	1002171c <alt_remap_uncached>

10020bac <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
10020bac:	defffe04 	addi	sp,sp,-8
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
10020bb0:	d1600504 	addi	r5,gp,-32748
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
10020bb4:	dc000015 	stw	r16,0(sp)
10020bb8:	dfc00115 	stw	ra,4(sp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
10020bbc:	00215580 	call	10021558 <alt_find_dev>
10020bc0:	1021883a 	mov	r16,r2

  if (NULL == dev) {
10020bc4:	10000526 	beq	r2,zero,10020bdc <alt_avalon_sgdma_open+0x30>
    ALT_ERRNO = ENODEV;
  }

  return dev;
}
10020bc8:	8005883a 	mov	r2,r16
10020bcc:	dfc00117 	ldw	ra,4(sp)
10020bd0:	dc000017 	ldw	r16,0(sp)
10020bd4:	dec00204 	addi	sp,sp,8
10020bd8:	f800283a 	ret
10020bdc:	00800034 	movhi	r2,0
10020be0:	10807104 	addi	r2,r2,452
10020be4:	10800017 	ldw	r2,0(r2)
10020be8:	00c00034 	movhi	r3,0
10020bec:	18c07504 	addi	r3,r3,468
10020bf0:	10000226 	beq	r2,zero,10020bfc <alt_avalon_sgdma_open+0x50>
10020bf4:	103ee83a 	callr	r2
10020bf8:	1007883a 	mov	r3,r2
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);

  if (NULL == dev) {
    ALT_ERRNO = ENODEV;
10020bfc:	008004c4 	movi	r2,19
10020c00:	18800015 	stw	r2,0(r3)
  }

  return dev;
}
10020c04:	8005883a 	mov	r2,r16
10020c08:	dfc00117 	ldw	ra,4(sp)
10020c0c:	dc000017 	ldw	r16,0(sp)
10020c10:	dec00204 	addi	sp,sp,8
10020c14:	f800283a 	ret

10020c18 <alt_avalon_sgdma_check_descriptor_status>:
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
10020c18:	208007a3 	ldbuio	r2,30(r4)
10020c1c:	00fffec4 	movi	r3,-5
10020c20:	10801fcc 	andi	r2,r2,127
10020c24:	10000226 	beq	r2,zero,10020c30 <alt_avalon_sgdma_check_descriptor_status+0x18>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
  }

    return 0;
}
10020c28:	1805883a 	mov	r2,r3
10020c2c:	f800283a 	ret
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  }

  if( IORD_8DIRECT(&desc->control, 0) &
10020c30:	208007e3 	ldbuio	r2,31(r4)
10020c34:	00ffe244 	movi	r3,-119
10020c38:	1080200c 	andi	r2,r2,128
10020c3c:	103ffa1e 	bne	r2,zero,10020c28 <alt_avalon_sgdma_check_descriptor_status+0x10>
10020c40:	0007883a 	mov	r3,zero
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
  }

    return 0;
}
10020c44:	1805883a 	mov	r2,r3
10020c48:	f800283a 	ret

10020c4c <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
10020c4c:	defff804 	addi	sp,sp,-32
10020c50:	dd400515 	stw	r21,20(sp)
10020c54:	ddc00715 	stw	r23,28(sp)
10020c58:	dd800615 	stw	r22,24(sp)
10020c5c:	dd000415 	stw	r20,16(sp)
10020c60:	dcc00315 	stw	r19,12(sp)
10020c64:	dc800215 	stw	r18,8(sp)
10020c68:	dc400115 	stw	r17,4(sp)
10020c6c:	dc000015 	stw	r16,0(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020c70:	288007c3 	ldbu	r2,31(r5)
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
10020c74:	d8c00917 	ldw	r3,36(sp)
10020c78:	da000a17 	ldw	r8,40(sp)
10020c7c:	da400b17 	ldw	r9,44(sp)
10020c80:	da80080b 	ldhu	r10,32(sp)
10020c84:	dac00c03 	ldbu	r11,48(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020c88:	10801fcc 	andi	r2,r2,127
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
10020c8c:	202b883a 	mov	r21,r4
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020c90:	288007e5 	stbio	r2,31(r5)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020c94:	3022d63a 	srli	r17,r6,24
  desc->write_addr               = write_addr;
10020c98:	3824d63a 	srli	r18,r7,24
  desc->next                     = (alt_u32 *) next;
10020c9c:	2826d63a 	srli	r19,r5,24
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10020ca0:	5028d23a 	srli	r20,r10,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020ca4:	3008d23a 	srli	r4,r6,8
10020ca8:	3018d43a 	srli	r12,r6,16
  desc->write_addr               = write_addr;
10020cac:	381ad23a 	srli	r13,r7,8
10020cb0:	381cd43a 	srli	r14,r7,16
  desc->next                     = (alt_u32 *) next;
10020cb4:	281ed23a 	srli	r15,r5,8
10020cb8:	2820d43a 	srli	r16,r5,16
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020cbc:	00bfe044 	movi	r2,-127
10020cc0:	1807003a 	cmpeq	r3,r3,zero
10020cc4:	4010c03a 	cmpne	r8,r8,zero
10020cc8:	4812c03a 	cmpne	r9,r9,zero
10020ccc:	10c7c83a 	sub	r3,r2,r3
10020cd0:	5d8003cc 	andi	r22,r11,15
10020cd4:	002f883a 	mov	r23,zero
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020cd8:	a9000045 	stb	r4,1(r21)
10020cdc:	ab000085 	stb	r12,2(r21)
10020ce0:	ac4000c5 	stb	r17,3(r21)
  desc->write_addr               = write_addr;
10020ce4:	ab400245 	stb	r13,9(r21)
10020ce8:	ab800285 	stb	r14,10(r21)
10020cec:	ac8002c5 	stb	r18,11(r21)
  desc->next                     = (alt_u32 *) next;
10020cf0:	abc00445 	stb	r15,17(r21)
10020cf4:	ac000485 	stb	r16,18(r21)
10020cf8:	acc004c5 	stb	r19,19(r21)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10020cfc:	ad000645 	stb	r20,25(r21)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020d00:	4211883a 	add	r8,r8,r8
10020d04:	480490ba 	slli	r2,r9,2
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020d08:	a9800005 	stb	r6,0(r21)
  desc->write_addr               = write_addr;
10020d0c:	a9c00205 	stb	r7,8(r21)
  desc->next                     = (alt_u32 *) next;
10020d10:	a9400405 	stb	r5,16(r21)
  desc->read_addr_pad            = 0x0;
10020d14:	a8000105 	stb	zero,4(r21)
10020d18:	a8000145 	stb	zero,5(r21)
10020d1c:	a8000185 	stb	zero,6(r21)
10020d20:	a80001c5 	stb	zero,7(r21)
  desc->write_addr_pad           = 0x0;
10020d24:	a8000305 	stb	zero,12(r21)
10020d28:	a8000345 	stb	zero,13(r21)
10020d2c:	a8000385 	stb	zero,14(r21)
10020d30:	a80003c5 	stb	zero,15(r21)
  desc->next_pad                 = 0x0;
10020d34:	a8000505 	stb	zero,20(r21)
10020d38:	a8000545 	stb	zero,21(r21)
10020d3c:	a8000585 	stb	zero,22(r21)
10020d40:	a80005c5 	stb	zero,23(r21)
  desc->bytes_to_transfer        = length_or_eop;
10020d44:	aa800605 	stb	r10,24(r21)
  desc->actual_bytes_transferred = 0;
10020d48:	a8000705 	stb	zero,28(r21)
10020d4c:	a8000745 	stb	zero,29(r21)
  desc->status                   = 0x0;
10020d50:	a8000785 	stb	zero,30(r21)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
10020d54:	a8000685 	stb	zero,26(r21)
  desc->write_burst              = write_burst;
10020d58:	a80006c5 	stb	zero,27(r21)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020d5c:	58000126 	beq	r11,zero,10020d64 <alt_avalon_sgdma_construct_descriptor+0x118>
10020d60:	b02e90fa 	slli	r23,r22,3
10020d64:	1204b03a 	or	r2,r2,r8
10020d68:	1dc6b03a 	or	r3,r3,r23
10020d6c:	10c4b03a 	or	r2,r2,r3
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10020d70:	a809883a 	mov	r4,r21
10020d74:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020d78:	a88007c5 	stb	r2,31(r21)
  alt_u8                atlantic_channel)
{
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
10020d7c:	ddc00717 	ldw	r23,28(sp)
10020d80:	dd800617 	ldw	r22,24(sp)
10020d84:	dd400517 	ldw	r21,20(sp)
10020d88:	dd000417 	ldw	r20,16(sp)
10020d8c:	dcc00317 	ldw	r19,12(sp)
10020d90:	dc800217 	ldw	r18,8(sp)
10020d94:	dc400117 	ldw	r17,4(sp)
10020d98:	dc000017 	ldw	r16,0(sp)
10020d9c:	dec00804 	addi	sp,sp,32
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10020da0:	002171c1 	jmpi	1002171c <alt_remap_uncached>

10020da4 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
10020da4:	deffff04 	addi	sp,sp,-4
10020da8:	dc000015 	stw	r16,0(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020dac:	28c007c3 	ldbu	r3,31(r5)
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
10020db0:	da000117 	ldw	r8,4(sp)
10020db4:	dc000217 	ldw	r16,8(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020db8:	18c01fcc 	andi	r3,r3,127
10020dbc:	28c007e5 	stbio	r3,31(r5)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020dc0:	4010c03a 	cmpne	r8,r8,zero
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10020dc4:	39ffffcc 	andi	r7,r7,65535
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020dc8:	401090ba 	slli	r8,r8,2
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10020dcc:	281cd63a 	srli	r14,r5,24
10020dd0:	2816d23a 	srli	r11,r5,8
10020dd4:	2818d43a 	srli	r12,r5,16
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
10020dd8:	301ad63a 	srli	r13,r6,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10020ddc:	381ed23a 	srli	r15,r7,8
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
10020de0:	3012d23a 	srli	r9,r6,8
10020de4:	3014d43a 	srli	r10,r6,16
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020de8:	00ffe004 	movi	r3,-128
10020dec:	40d0b03a 	or	r8,r8,r3
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10020df0:	21400405 	stb	r5,16(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10020df4:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020df8:	220007c5 	stb	r8,31(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
10020dfc:	22400245 	stb	r9,9(r4)
10020e00:	22800285 	stb	r10,10(r4)
10020e04:	234002c5 	stb	r13,11(r4)
  desc->next                     = (alt_u32 *) next;
10020e08:	22c00445 	stb	r11,17(r4)
10020e0c:	23000485 	stb	r12,18(r4)
10020e10:	238004c5 	stb	r14,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10020e14:	23c00645 	stb	r15,25(r4)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  desc->write_burst              = write_burst;
10020e18:	240006c5 	stb	r16,27(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020e1c:	20000005 	stb	zero,0(r4)
10020e20:	20000045 	stb	zero,1(r4)
10020e24:	20000085 	stb	zero,2(r4)
10020e28:	200000c5 	stb	zero,3(r4)
  desc->write_addr               = write_addr;
10020e2c:	21800205 	stb	r6,8(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
10020e30:	20000105 	stb	zero,4(r4)
10020e34:	20000145 	stb	zero,5(r4)
10020e38:	20000185 	stb	zero,6(r4)
10020e3c:	200001c5 	stb	zero,7(r4)
  desc->write_addr_pad           = 0x0;
10020e40:	20000305 	stb	zero,12(r4)
10020e44:	20000345 	stb	zero,13(r4)
10020e48:	20000385 	stb	zero,14(r4)
10020e4c:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
10020e50:	20000505 	stb	zero,20(r4)
10020e54:	20000545 	stb	zero,21(r4)
10020e58:	20000585 	stb	zero,22(r4)
10020e5c:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
10020e60:	21c00605 	stb	r7,24(r4)
  desc->actual_bytes_transferred = 0;
10020e64:	20000705 	stb	zero,28(r4)
10020e68:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
10020e6c:	20000785 	stb	zero,30(r4)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
10020e70:	20000685 	stb	zero,26(r4)
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
10020e74:	dc000017 	ldw	r16,0(sp)
10020e78:	dec00104 	addi	sp,sp,4
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10020e7c:	002171c1 	jmpi	1002171c <alt_remap_uncached>

10020e80 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
10020e80:	defff904 	addi	sp,sp,-28
10020e84:	dd800615 	stw	r22,24(sp)
10020e88:	dd400515 	stw	r21,20(sp)
10020e8c:	dd000415 	stw	r20,16(sp)
10020e90:	dcc00315 	stw	r19,12(sp)
10020e94:	dc800215 	stw	r18,8(sp)
10020e98:	dc400115 	stw	r17,4(sp)
10020e9c:	dc000015 	stw	r16,0(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020ea0:	28c007c3 	ldbu	r3,31(r5)
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
10020ea4:	da400817 	ldw	r9,32(sp)
10020ea8:	da000917 	ldw	r8,36(sp)
10020eac:	dd400a17 	ldw	r21,40(sp)
10020eb0:	dd800b17 	ldw	r22,44(sp)
10020eb4:	db00070b 	ldhu	r12,28(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020eb8:	18c01fcc 	andi	r3,r3,127
10020ebc:	28c007e5 	stbio	r3,31(r5)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020ec0:	4010c03a 	cmpne	r8,r8,zero
10020ec4:	4812c03a 	cmpne	r9,r9,zero
10020ec8:	401090ba 	slli	r8,r8,2
10020ecc:	4a53883a 	add	r9,r9,r9
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10020ed0:	2826d63a 	srli	r19,r5,24
10020ed4:	281ed23a 	srli	r15,r5,8
10020ed8:	2820d43a 	srli	r16,r5,16
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020edc:	3022d63a 	srli	r17,r6,24
  desc->write_addr               = write_addr;
10020ee0:	3824d63a 	srli	r18,r7,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10020ee4:	6028d23a 	srli	r20,r12,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020ee8:	3014d23a 	srli	r10,r6,8
10020eec:	3016d43a 	srli	r11,r6,16
  desc->write_addr               = write_addr;
10020ef0:	381ad23a 	srli	r13,r7,8
10020ef4:	381cd43a 	srli	r14,r7,16
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020ef8:	00ffe004 	movi	r3,-128
10020efc:	40d0b03a 	or	r8,r8,r3
10020f00:	4250b03a 	or	r8,r8,r9
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10020f04:	21400405 	stb	r5,16(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10020f08:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10020f0c:	220007c5 	stb	r8,31(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020f10:	22800045 	stb	r10,1(r4)
10020f14:	22c00085 	stb	r11,2(r4)
10020f18:	244000c5 	stb	r17,3(r4)
  desc->write_addr               = write_addr;
10020f1c:	23400245 	stb	r13,9(r4)
10020f20:	23800285 	stb	r14,10(r4)
10020f24:	248002c5 	stb	r18,11(r4)
  desc->next                     = (alt_u32 *) next;
10020f28:	23c00445 	stb	r15,17(r4)
10020f2c:	24000485 	stb	r16,18(r4)
10020f30:	24c004c5 	stb	r19,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10020f34:	25000645 	stb	r20,25(r4)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
10020f38:	25400685 	stb	r21,26(r4)
  desc->write_burst              = write_burst;
10020f3c:	258006c5 	stb	r22,27(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020f40:	21800005 	stb	r6,0(r4)
  desc->write_addr               = write_addr;
10020f44:	21c00205 	stb	r7,8(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
10020f48:	20000105 	stb	zero,4(r4)
10020f4c:	20000145 	stb	zero,5(r4)
10020f50:	20000185 	stb	zero,6(r4)
10020f54:	200001c5 	stb	zero,7(r4)
  desc->write_addr_pad           = 0x0;
10020f58:	20000305 	stb	zero,12(r4)
10020f5c:	20000345 	stb	zero,13(r4)
10020f60:	20000385 	stb	zero,14(r4)
10020f64:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
10020f68:	20000505 	stb	zero,20(r4)
10020f6c:	20000545 	stb	zero,21(r4)
10020f70:	20000585 	stb	zero,22(r4)
10020f74:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
10020f78:	23000605 	stb	r12,24(r4)
  desc->actual_bytes_transferred = 0;
10020f7c:	20000705 	stb	zero,28(r4)
10020f80:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
10020f84:	20000785 	stb	zero,30(r4)
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
10020f88:	dd800617 	ldw	r22,24(sp)
10020f8c:	dd400517 	ldw	r21,20(sp)
10020f90:	dd000417 	ldw	r20,16(sp)
10020f94:	dcc00317 	ldw	r19,12(sp)
10020f98:	dc800217 	ldw	r18,8(sp)
10020f9c:	dc400117 	ldw	r17,4(sp)
10020fa0:	dc000017 	ldw	r16,0(sp)
10020fa4:	dec00704 	addi	sp,sp,28
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10020fa8:	002171c1 	jmpi	1002171c <alt_remap_uncached>

10020fac <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
10020fac:	defffb04 	addi	sp,sp,-20
10020fb0:	dc800215 	stw	r18,8(sp)
10020fb4:	dc400115 	stw	r17,4(sp)
10020fb8:	dd000415 	stw	r20,16(sp)
10020fbc:	dcc00315 	stw	r19,12(sp)
10020fc0:	dc000015 	stw	r16,0(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020fc4:	288007c3 	ldbu	r2,31(r5)
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
10020fc8:	da000517 	ldw	r8,20(sp)
10020fcc:	da400617 	ldw	r9,24(sp)
10020fd0:	d8c00717 	ldw	r3,28(sp)
10020fd4:	dc400817 	ldw	r17,32(sp)
10020fd8:	da800903 	ldbu	r10,36(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020fdc:	10801fcc 	andi	r2,r2,127
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
10020fe0:	2025883a 	mov	r18,r4
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10020fe4:	288007e5 	stbio	r2,31(r5)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10020fe8:	39ffffcc 	andi	r7,r7,65535
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020fec:	301cd63a 	srli	r14,r6,24
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10020ff0:	281ed63a 	srli	r15,r5,24
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10020ff4:	3820d23a 	srli	r16,r7,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10020ff8:	3008d23a 	srli	r4,r6,8
10020ffc:	3016d43a 	srli	r11,r6,16
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10021000:	2818d23a 	srli	r12,r5,8
10021004:	281ad43a 	srli	r13,r5,16
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10021008:	00bfe044 	movi	r2,-127
1002100c:	1807003a 	cmpeq	r3,r3,zero
10021010:	4010c03a 	cmpne	r8,r8,zero
10021014:	4812c03a 	cmpne	r9,r9,zero
10021018:	10c7c83a 	sub	r3,r2,r3
1002101c:	54c003cc 	andi	r19,r10,15
10021020:	0029883a 	mov	r20,zero
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10021024:	91000045 	stb	r4,1(r18)
10021028:	92c00085 	stb	r11,2(r18)
1002102c:	938000c5 	stb	r14,3(r18)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10021030:	93000445 	stb	r12,17(r18)
10021034:	93400485 	stb	r13,18(r18)
10021038:	93c004c5 	stb	r15,19(r18)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
1002103c:	94000645 	stb	r16,25(r18)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
10021040:	94400685 	stb	r17,26(r18)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10021044:	4211883a 	add	r8,r8,r8
10021048:	480490ba 	slli	r2,r9,2
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
1002104c:	91800005 	stb	r6,0(r18)
  desc->write_addr               = write_addr;
10021050:	90000205 	stb	zero,8(r18)
10021054:	90000245 	stb	zero,9(r18)
10021058:	90000285 	stb	zero,10(r18)
1002105c:	900002c5 	stb	zero,11(r18)
  desc->next                     = (alt_u32 *) next;
10021060:	91400405 	stb	r5,16(r18)
  desc->read_addr_pad            = 0x0;
10021064:	90000105 	stb	zero,4(r18)
10021068:	90000145 	stb	zero,5(r18)
1002106c:	90000185 	stb	zero,6(r18)
10021070:	900001c5 	stb	zero,7(r18)
  desc->write_addr_pad           = 0x0;
10021074:	90000305 	stb	zero,12(r18)
10021078:	90000345 	stb	zero,13(r18)
1002107c:	90000385 	stb	zero,14(r18)
10021080:	900003c5 	stb	zero,15(r18)
  desc->next_pad                 = 0x0;
10021084:	90000505 	stb	zero,20(r18)
10021088:	90000545 	stb	zero,21(r18)
1002108c:	90000585 	stb	zero,22(r18)
10021090:	900005c5 	stb	zero,23(r18)
  desc->bytes_to_transfer        = length_or_eop;
10021094:	91c00605 	stb	r7,24(r18)
  desc->actual_bytes_transferred = 0;
10021098:	90000705 	stb	zero,28(r18)
1002109c:	90000745 	stb	zero,29(r18)
  desc->status                   = 0x0;
100210a0:	90000785 	stb	zero,30(r18)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  desc->write_burst              = write_burst;
100210a4:	900006c5 	stb	zero,27(r18)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
100210a8:	50000126 	beq	r10,zero,100210b0 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst+0x104>
100210ac:	982890fa 	slli	r20,r19,3
100210b0:	4084b03a 	or	r2,r8,r2
100210b4:	a0c6b03a 	or	r3,r20,r3
100210b8:	10c4b03a 	or	r2,r2,r3
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
100210bc:	9009883a 	mov	r4,r18
100210c0:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
100210c4:	908007c5 	stb	r2,31(r18)
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
100210c8:	dd000417 	ldw	r20,16(sp)
100210cc:	dcc00317 	ldw	r19,12(sp)
100210d0:	dc800217 	ldw	r18,8(sp)
100210d4:	dc400117 	ldw	r17,4(sp)
100210d8:	dc000017 	ldw	r16,0(sp)
100210dc:	dec00504 	addi	sp,sp,20
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
100210e0:	002171c1 	jmpi	1002171c <alt_remap_uncached>

100210e4 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
100210e4:	defffb04 	addi	sp,sp,-20
100210e8:	dd000415 	stw	r20,16(sp)
100210ec:	dcc00315 	stw	r19,12(sp)
100210f0:	dc800215 	stw	r18,8(sp)
100210f4:	dc400115 	stw	r17,4(sp)
100210f8:	dc000015 	stw	r16,0(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
100210fc:	28c007c3 	ldbu	r3,31(r5)
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
10021100:	da400617 	ldw	r9,24(sp)
10021104:	da000717 	ldw	r8,28(sp)
10021108:	da80050b 	ldhu	r10,20(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
1002110c:	18c01fcc 	andi	r3,r3,127
10021110:	28c007e5 	stbio	r3,31(r5)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10021114:	4010c03a 	cmpne	r8,r8,zero
10021118:	4812c03a 	cmpne	r9,r9,zero
1002111c:	401090ba 	slli	r8,r8,2
10021120:	4a53883a 	add	r9,r9,r9
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10021124:	2826d63a 	srli	r19,r5,24
10021128:	281ed23a 	srli	r15,r5,8
1002112c:	2820d43a 	srli	r16,r5,16
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10021130:	3022d63a 	srli	r17,r6,24
  desc->write_addr               = write_addr;
10021134:	3824d63a 	srli	r18,r7,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10021138:	5028d23a 	srli	r20,r10,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
1002113c:	3016d23a 	srli	r11,r6,8
10021140:	3018d43a 	srli	r12,r6,16
  desc->write_addr               = write_addr;
10021144:	381ad23a 	srli	r13,r7,8
10021148:	381cd43a 	srli	r14,r7,16
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
1002114c:	00ffe004 	movi	r3,-128
10021150:	40d0b03a 	or	r8,r8,r3
10021154:	4250b03a 	or	r8,r8,r9
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10021158:	21400405 	stb	r5,16(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
1002115c:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10021160:	220007c5 	stb	r8,31(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10021164:	22c00045 	stb	r11,1(r4)
10021168:	23000085 	stb	r12,2(r4)
1002116c:	244000c5 	stb	r17,3(r4)
  desc->write_addr               = write_addr;
10021170:	23400245 	stb	r13,9(r4)
10021174:	23800285 	stb	r14,10(r4)
10021178:	248002c5 	stb	r18,11(r4)
  desc->next                     = (alt_u32 *) next;
1002117c:	23c00445 	stb	r15,17(r4)
10021180:	24000485 	stb	r16,18(r4)
10021184:	24c004c5 	stb	r19,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10021188:	25000645 	stb	r20,25(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
1002118c:	21800005 	stb	r6,0(r4)
  desc->write_addr               = write_addr;
10021190:	21c00205 	stb	r7,8(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
10021194:	20000105 	stb	zero,4(r4)
10021198:	20000145 	stb	zero,5(r4)
1002119c:	20000185 	stb	zero,6(r4)
100211a0:	200001c5 	stb	zero,7(r4)
  desc->write_addr_pad           = 0x0;
100211a4:	20000305 	stb	zero,12(r4)
100211a8:	20000345 	stb	zero,13(r4)
100211ac:	20000385 	stb	zero,14(r4)
100211b0:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
100211b4:	20000505 	stb	zero,20(r4)
100211b8:	20000545 	stb	zero,21(r4)
100211bc:	20000585 	stb	zero,22(r4)
100211c0:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
100211c4:	22800605 	stb	r10,24(r4)
  desc->actual_bytes_transferred = 0;
100211c8:	20000705 	stb	zero,28(r4)
100211cc:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
100211d0:	20000785 	stb	zero,30(r4)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
100211d4:	20000685 	stb	zero,26(r4)
  desc->write_burst              = write_burst;
100211d8:	200006c5 	stb	zero,27(r4)
  int                   read_fixed,
  int                   write_fixed)
{
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
100211dc:	dd000417 	ldw	r20,16(sp)
100211e0:	dcc00317 	ldw	r19,12(sp)
100211e4:	dc800217 	ldw	r18,8(sp)
100211e8:	dc400117 	ldw	r17,4(sp)
100211ec:	dc000017 	ldw	r16,0(sp)
100211f0:	dec00504 	addi	sp,sp,20
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
100211f4:	002171c1 	jmpi	1002171c <alt_remap_uncached>

100211f8 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
100211f8:	defffc04 	addi	sp,sp,-16
100211fc:	dc400115 	stw	r17,4(sp)
10021200:	dcc00315 	stw	r19,12(sp)
10021204:	dc800215 	stw	r18,8(sp)
10021208:	dc000015 	stw	r16,0(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
1002120c:	288007c3 	ldbu	r2,31(r5)
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
10021210:	da000417 	ldw	r8,16(sp)
10021214:	da400517 	ldw	r9,20(sp)
10021218:	d8c00617 	ldw	r3,24(sp)
1002121c:	da800703 	ldbu	r10,28(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10021220:	10801fcc 	andi	r2,r2,127
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
10021224:	2023883a 	mov	r17,r4
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10021228:	288007e5 	stbio	r2,31(r5)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
1002122c:	39ffffcc 	andi	r7,r7,65535
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10021230:	301cd63a 	srli	r14,r6,24
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10021234:	281ed63a 	srli	r15,r5,24
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10021238:	3820d23a 	srli	r16,r7,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
1002123c:	3008d23a 	srli	r4,r6,8
10021240:	3016d43a 	srli	r11,r6,16
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10021244:	2818d23a 	srli	r12,r5,8
10021248:	281ad43a 	srli	r13,r5,16
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
1002124c:	00bfe044 	movi	r2,-127
10021250:	1807003a 	cmpeq	r3,r3,zero
10021254:	4010c03a 	cmpne	r8,r8,zero
10021258:	4812c03a 	cmpne	r9,r9,zero
1002125c:	10c7c83a 	sub	r3,r2,r3
10021260:	548003cc 	andi	r18,r10,15
10021264:	0027883a 	mov	r19,zero
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
10021268:	89000045 	stb	r4,1(r17)
1002126c:	8ac00085 	stb	r11,2(r17)
10021270:	8b8000c5 	stb	r14,3(r17)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10021274:	8b000445 	stb	r12,17(r17)
10021278:	8b400485 	stb	r13,18(r17)
1002127c:	8bc004c5 	stb	r15,19(r17)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10021280:	8c000645 	stb	r16,25(r17)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10021284:	4211883a 	add	r8,r8,r8
10021288:	480490ba 	slli	r2,r9,2
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
1002128c:	89800005 	stb	r6,0(r17)
  desc->write_addr               = write_addr;
10021290:	88000205 	stb	zero,8(r17)
10021294:	88000245 	stb	zero,9(r17)
10021298:	88000285 	stb	zero,10(r17)
1002129c:	880002c5 	stb	zero,11(r17)
  desc->next                     = (alt_u32 *) next;
100212a0:	89400405 	stb	r5,16(r17)
  desc->read_addr_pad            = 0x0;
100212a4:	88000105 	stb	zero,4(r17)
100212a8:	88000145 	stb	zero,5(r17)
100212ac:	88000185 	stb	zero,6(r17)
100212b0:	880001c5 	stb	zero,7(r17)
  desc->write_addr_pad           = 0x0;
100212b4:	88000305 	stb	zero,12(r17)
100212b8:	88000345 	stb	zero,13(r17)
100212bc:	88000385 	stb	zero,14(r17)
100212c0:	880003c5 	stb	zero,15(r17)
  desc->next_pad                 = 0x0;
100212c4:	88000505 	stb	zero,20(r17)
100212c8:	88000545 	stb	zero,21(r17)
100212cc:	88000585 	stb	zero,22(r17)
100212d0:	880005c5 	stb	zero,23(r17)
  desc->bytes_to_transfer        = length_or_eop;
100212d4:	89c00605 	stb	r7,24(r17)
  desc->actual_bytes_transferred = 0;
100212d8:	88000705 	stb	zero,28(r17)
100212dc:	88000745 	stb	zero,29(r17)
  desc->status                   = 0x0;
100212e0:	88000785 	stb	zero,30(r17)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
100212e4:	88000685 	stb	zero,26(r17)
  desc->write_burst              = write_burst;
100212e8:	880006c5 	stb	zero,27(r17)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
100212ec:	50000126 	beq	r10,zero,100212f4 <alt_avalon_sgdma_construct_mem_to_stream_desc+0xfc>
100212f0:	902690fa 	slli	r19,r18,3
100212f4:	4084b03a 	or	r2,r8,r2
100212f8:	1cc6b03a 	or	r3,r3,r19
100212fc:	10c4b03a 	or	r2,r2,r3
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10021300:	8809883a 	mov	r4,r17
10021304:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10021308:	888007c5 	stb	r2,31(r17)
  alt_u8                atlantic_channel)
{
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
1002130c:	dcc00317 	ldw	r19,12(sp)
10021310:	dc800217 	ldw	r18,8(sp)
10021314:	dc400117 	ldw	r17,4(sp)
10021318:	dc000017 	ldw	r16,0(sp)
1002131c:	dec00404 	addi	sp,sp,16
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10021320:	002171c1 	jmpi	1002171c <alt_remap_uncached>

10021324 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
10021324:	28c007c3 	ldbu	r3,31(r5)
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
10021328:	da000017 	ldw	r8,0(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
1002132c:	18c01fcc 	andi	r3,r3,127
10021330:	28c007e5 	stbio	r3,31(r5)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
10021334:	4010c03a 	cmpne	r8,r8,zero
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10021338:	39ffffcc 	andi	r7,r7,65535
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
1002133c:	401090ba 	slli	r8,r8,2
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10021340:	281cd63a 	srli	r14,r5,24
10021344:	2816d23a 	srli	r11,r5,8
10021348:	2818d43a 	srli	r12,r5,16
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
1002134c:	301ad63a 	srli	r13,r6,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10021350:	381ed23a 	srli	r15,r7,8
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
10021354:	3012d23a 	srli	r9,r6,8
10021358:	3014d43a 	srli	r10,r6,16
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
1002135c:	00ffe004 	movi	r3,-128
10021360:	40d0b03a 	or	r8,r8,r3
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
10021364:	21400405 	stb	r5,16(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
10021368:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
1002136c:	220007c5 	stb	r8,31(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
10021370:	22400245 	stb	r9,9(r4)
10021374:	22800285 	stb	r10,10(r4)
10021378:	234002c5 	stb	r13,11(r4)
  desc->next                     = (alt_u32 *) next;
1002137c:	22c00445 	stb	r11,17(r4)
10021380:	23000485 	stb	r12,18(r4)
10021384:	238004c5 	stb	r14,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
10021388:	23c00645 	stb	r15,25(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
1002138c:	20000005 	stb	zero,0(r4)
10021390:	20000045 	stb	zero,1(r4)
10021394:	20000085 	stb	zero,2(r4)
10021398:	200000c5 	stb	zero,3(r4)
  desc->write_addr               = write_addr;
1002139c:	21800205 	stb	r6,8(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
100213a0:	20000105 	stb	zero,4(r4)
100213a4:	20000145 	stb	zero,5(r4)
100213a8:	20000185 	stb	zero,6(r4)
100213ac:	200001c5 	stb	zero,7(r4)
  desc->write_addr_pad           = 0x0;
100213b0:	20000305 	stb	zero,12(r4)
100213b4:	20000345 	stb	zero,13(r4)
100213b8:	20000385 	stb	zero,14(r4)
100213bc:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
100213c0:	20000505 	stb	zero,20(r4)
100213c4:	20000545 	stb	zero,21(r4)
100213c8:	20000585 	stb	zero,22(r4)
100213cc:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
100213d0:	21c00605 	stb	r7,24(r4)
  desc->actual_bytes_transferred = 0;
100213d4:	20000705 	stb	zero,28(r4)
100213d8:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
100213dc:	20000785 	stb	zero,30(r4)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
100213e0:	20000685 	stb	zero,26(r4)
  desc->write_burst              = write_burst;
100213e4:	200006c5 	stb	zero,27(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
100213e8:	002171c1 	jmpi	1002171c <alt_remap_uncached>

100213ec <close>:
#include "os/alt_syscall.h"

#ifdef ALT_USE_DIRECT_DRIVERS

int ALT_CLOSE (int fildes)
{
100213ec:	deffff04 	addi	sp,sp,-4
100213f0:	dfc00015 	stw	ra,0(sp)
100213f4:	00800034 	movhi	r2,0
100213f8:	10807104 	addi	r2,r2,452
100213fc:	10800017 	ldw	r2,0(r2)
10021400:	00c00034 	movhi	r3,0
10021404:	18c07504 	addi	r3,r3,468
10021408:	10000226 	beq	r2,zero,10021414 <close+0x28>
1002140c:	103ee83a 	callr	r2
10021410:	1007883a 	mov	r3,r2
  
  ALT_STUB_WARNING(close);
  
  /* Indicate an error */
  
  ALT_ERRNO = ENOSYS;
10021414:	00801604 	movi	r2,88
10021418:	18800015 	stw	r2,0(r3)
  return -1;
}
1002141c:	00bfffc4 	movi	r2,-1
10021420:	dfc00017 	ldw	ra,0(sp)
10021424:	dec00104 	addi	sp,sp,4
10021428:	f800283a 	ret

1002142c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
1002142c:	0005883a 	mov	r2,zero
10021430:	00c20004 	movi	r3,2048
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
10021434:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
10021438:	10800804 	addi	r2,r2,32
1002143c:	10fffd1e 	bne	r2,r3,10021434 <alt_dcache_flush_all+0x8>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
10021440:	f800283a 	ret

10021444 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
10021444:	deffff04 	addi	sp,sp,-4
10021448:	dfc00015 	stw	ra,0(sp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
1002144c:	20000d26 	beq	r4,zero,10021484 <alt_dev_llist_insert+0x40>
10021450:	20800217 	ldw	r2,8(r4)
{
  entry->previous = list;
  entry->next     = list->next;

  list->next->previous = entry;
  list->next           = entry;
10021454:	000d883a 	mov	r6,zero
10021458:	10000a26 	beq	r2,zero,10021484 <alt_dev_llist_insert+0x40>

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
1002145c:	28c00017 	ldw	r3,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
10021460:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
10021464:	20c00015 	stw	r3,0(r4)

  list->next->previous = entry;
10021468:	28800017 	ldw	r2,0(r5)
  list->next           = entry;
1002146c:	29000015 	stw	r4,0(r5)
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;

  list->next->previous = entry;
10021470:	11000115 	stw	r4,4(r2)
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
10021474:	3005883a 	mov	r2,r6
10021478:	dfc00017 	ldw	ra,0(sp)
1002147c:	dec00104 	addi	sp,sp,4
10021480:	f800283a 	ret
10021484:	00800034 	movhi	r2,0
10021488:	10807104 	addi	r2,r2,452
1002148c:	10800017 	ldw	r2,0(r2)
10021490:	00c00034 	movhi	r3,0
10021494:	18c07504 	addi	r3,r3,468
10021498:	10000226 	beq	r2,zero,100214a4 <alt_dev_llist_insert+0x60>
1002149c:	103ee83a 	callr	r2
100214a0:	1007883a 	mov	r3,r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
100214a4:	01bffa84 	movi	r6,-22
100214a8:	00800584 	movi	r2,22
100214ac:	18800015 	stw	r2,0(r3)
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
100214b0:	3005883a 	mov	r2,r6
100214b4:	dfc00017 	ldw	ra,0(sp)
100214b8:	dec00104 	addi	sp,sp,4
100214bc:	f800283a 	ret

100214c0 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
100214c0:	defffd04 	addi	sp,sp,-12
100214c4:	dc400115 	stw	r17,4(sp)
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
100214c8:	008400b4 	movhi	r2,4098
100214cc:	1086d704 	addi	r2,r2,7004
100214d0:	044400b4 	movhi	r17,4098
100214d4:	8c46d704 	addi	r17,r17,7004
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
100214d8:	dfc00215 	stw	ra,8(sp)
100214dc:	dc000015 	stw	r16,0(sp)
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
100214e0:	14400536 	bltu	r2,r17,100214f8 <_do_ctors+0x38>
100214e4:	1021883a 	mov	r16,r2
        (*ctor) (); 
100214e8:	80800017 	ldw	r2,0(r16)

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
100214ec:	843fff04 	addi	r16,r16,-4
        (*ctor) (); 
100214f0:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
100214f4:	847ffc2e 	bgeu	r16,r17,100214e8 <_do_ctors+0x28>
        (*ctor) (); 
}
100214f8:	dfc00217 	ldw	ra,8(sp)
100214fc:	dc400117 	ldw	r17,4(sp)
10021500:	dc000017 	ldw	r16,0(sp)
10021504:	dec00304 	addi	sp,sp,12
10021508:	f800283a 	ret

1002150c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
1002150c:	defffd04 	addi	sp,sp,-12
10021510:	dc400115 	stw	r17,4(sp)
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
10021514:	008400b4 	movhi	r2,4098
10021518:	1086d704 	addi	r2,r2,7004
1002151c:	044400b4 	movhi	r17,4098
10021520:	8c46d804 	addi	r17,r17,7008
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
10021524:	dfc00215 	stw	ra,8(sp)
10021528:	dc000015 	stw	r16,0(sp)
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
1002152c:	14400536 	bltu	r2,r17,10021544 <_do_dtors+0x38>
10021530:	1021883a 	mov	r16,r2
        (*dtor) (); 
10021534:	80800017 	ldw	r2,0(r16)

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
10021538:	843fff04 	addi	r16,r16,-4
        (*dtor) (); 
1002153c:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
10021540:	847ffc2e 	bgeu	r16,r17,10021534 <_do_dtors+0x28>
        (*dtor) (); 
}
10021544:	dfc00217 	ldw	ra,8(sp)
10021548:	dc400117 	ldw	r17,4(sp)
1002154c:	dc000017 	ldw	r16,0(sp)
10021550:	dec00304 	addi	sp,sp,12
10021554:	f800283a 	ret

10021558 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
10021558:	defffb04 	addi	sp,sp,-20
1002155c:	dc000015 	stw	r16,0(sp)
  alt_dev* next = (alt_dev*) llist->next;
10021560:	2c000017 	ldw	r16,0(r5)
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
10021564:	dcc00315 	stw	r19,12(sp)
10021568:	dc400115 	stw	r17,4(sp)
1002156c:	dfc00415 	stw	ra,16(sp)
10021570:	2823883a 	mov	r17,r5
10021574:	dc800215 	stw	r18,8(sp)
10021578:	2027883a 	mov	r19,r4
  alt_dev* next = (alt_dev*) llist->next;
  alt_32 len;

  len  = strlen(name) + 1;
1002157c:	00204480 	call	10020448 <strlen>
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
10021580:	84401126 	beq	r16,r17,100215c8 <alt_find_dev+0x70>
10021584:	14800044 	addi	r18,r2,1
10021588:	00000206 	br	10021594 <alt_find_dev+0x3c>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
1002158c:	84000017 	ldw	r16,0(r16)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
10021590:	84400d26 	beq	r16,r17,100215c8 <alt_find_dev+0x70>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
10021594:	81000217 	ldw	r4,8(r16)
10021598:	980b883a 	mov	r5,r19
1002159c:	900d883a 	mov	r6,r18
100215a0:	00217e00 	call	100217e0 <memcmp>
100215a4:	103ff91e 	bne	r2,zero,1002158c <alt_find_dev+0x34>
  }
  
  /* No match found */
  
  return NULL;
}
100215a8:	8005883a 	mov	r2,r16
100215ac:	dfc00417 	ldw	ra,16(sp)
100215b0:	dcc00317 	ldw	r19,12(sp)
100215b4:	dc800217 	ldw	r18,8(sp)
100215b8:	dc400117 	ldw	r17,4(sp)
100215bc:	dc000017 	ldw	r16,0(sp)
100215c0:	dec00504 	addi	sp,sp,20
100215c4:	f800283a 	ret
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
100215c8:	0021883a 	mov	r16,zero
  }
  
  /* No match found */
  
  return NULL;
}
100215cc:	8005883a 	mov	r2,r16
100215d0:	dfc00417 	ldw	ra,16(sp)
100215d4:	dcc00317 	ldw	r19,12(sp)
100215d8:	dc800217 	ldw	r18,8(sp)
100215dc:	dc400117 	ldw	r17,4(sp)
100215e0:	dc000017 	ldw	r16,0(sp)
100215e4:	dec00504 	addi	sp,sp,20
100215e8:	f800283a 	ret

100215ec <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
100215ec:	0009883a 	mov	r4,zero
100215f0:	01440004 	movi	r5,4096
100215f4:	00217741 	jmpi	10021774 <alt_icache_flush>

100215f8 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
100215f8:	000530fa 	rdctl	r2,ienable
100215fc:	00c00044 	movi	r3,1
10021600:	1946983a 	sll	r3,r3,r5
10021604:	10c4703a 	and	r2,r2,r3

    return (irq_enabled & (1 << irq)) ? 1: 0;
}
10021608:	1004c03a 	cmpne	r2,r2,zero
1002160c:	f800283a 	ret

10021610 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10021610:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10021614:	00bfff84 	movi	r2,-2
10021618:	3084703a 	and	r2,r6,r2
1002161c:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
10021620:	01000034 	movhi	r4,0
10021624:	21007904 	addi	r4,r4,484
10021628:	00800044 	movi	r2,1
1002162c:	20c00017 	ldw	r3,0(r4)
10021630:	1144983a 	sll	r2,r2,r5
10021634:	10c4b03a 	or	r2,r2,r3
10021638:	20800015 	stw	r2,0(r4)
  NIOS2_WRITE_IENABLE (alt_irq_active);
1002163c:	20c00017 	ldw	r3,0(r4)
10021640:	180170fa 	wrctl	ienable,r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10021644:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
10021648:	0005883a 	mov	r2,zero
1002164c:	f800283a 	ret

10021650 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
10021650:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
10021654:	00bfff84 	movi	r2,-2
10021658:	3084703a 	and	r2,r6,r2
1002165c:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
10021660:	01000034 	movhi	r4,0
10021664:	21007904 	addi	r4,r4,484
10021668:	00bfff84 	movi	r2,-2
1002166c:	20c00017 	ldw	r3,0(r4)
10021670:	1144183a 	rol	r2,r2,r5
10021674:	10c4703a 	and	r2,r2,r3
10021678:	20800015 	stw	r2,0(r4)
  NIOS2_WRITE_IENABLE (alt_irq_active);
1002167c:	20c00017 	ldw	r3,0(r4)
10021680:	180170fa 	wrctl	ienable,r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
10021684:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
10021688:	0005883a 	mov	r2,zero
1002168c:	f800283a 	ret

10021690 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
10021690:	00216941 	jmpi	10021694 <alt_iic_isr_register>

10021694 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
10021694:	defffe04 	addi	sp,sp,-8
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
10021698:	008007c4 	movi	r2,31
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
1002169c:	dfc00115 	stw	ra,4(sp)
100216a0:	dc000015 	stw	r16,0(sp)
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
100216a4:	023ffa84 	movi	r8,-22
100216a8:	1140050e 	bge	r2,r5,100216c0 <alt_iic_isr_register+0x2c>

    alt_irq_enable_all(status);
  }

  return rc; 
}
100216ac:	4005883a 	mov	r2,r8
100216b0:	dfc00117 	ldw	ra,4(sp)
100216b4:	dc000017 	ldw	r16,0(sp)
100216b8:	dec00204 	addi	sp,sp,8
100216bc:	f800283a 	ret
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
100216c0:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
100216c4:	00bfff84 	movi	r2,-2
100216c8:	8084703a 	and	r2,r16,r2
100216cc:	1001703a 	wrctl	status,r2
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
100216d0:	280690fa 	slli	r3,r5,3
100216d4:	00800034 	movhi	r2,0
100216d8:	10807a04 	addi	r2,r2,488
100216dc:	1887883a 	add	r3,r3,r2
    alt_irq[id].context = isr_context;
100216e0:	19c00115 	stw	r7,4(r3)
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
100216e4:	19800015 	stw	r6,0(r3)
    alt_irq[id].context = isr_context;

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
100216e8:	30000826 	beq	r6,zero,1002170c <alt_iic_isr_register+0x78>
100216ec:	00216100 	call	10021610 <alt_ic_irq_enable>
100216f0:	1011883a 	mov	r8,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
100216f4:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
100216f8:	4005883a 	mov	r2,r8
100216fc:	dfc00117 	ldw	ra,4(sp)
10021700:	dc000017 	ldw	r16,0(sp)
10021704:	dec00204 	addi	sp,sp,8
10021708:	f800283a 	ret
    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
    alt_irq[id].context = isr_context;

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
1002170c:	00216500 	call	10021650 <alt_ic_irq_disable>
10021710:	1011883a 	mov	r8,r2
10021714:	8001703a 	wrctl	status,r16
10021718:	003ff706 	br	100216f8 <alt_iic_isr_register+0x64>

1002171c <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
1002171c:	defffe04 	addi	sp,sp,-8
10021720:	dc000015 	stw	r16,0(sp)
10021724:	dfc00115 	stw	ra,4(sp)
10021728:	2021883a 	mov	r16,r4
  alt_dcache_flush (ptr, len);
1002172c:	002174c0 	call	1002174c <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
}
10021730:	80a00034 	orhi	r2,r16,32768
10021734:	dfc00117 	ldw	ra,4(sp)
10021738:	dc000017 	ldw	r16,0(sp)
1002173c:	dec00204 	addi	sp,sp,8
10021740:	f800283a 	ret

10021744 <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
10021744:	000170fa 	wrctl	ienable,zero
}
10021748:	f800283a 	ret

1002174c <alt_dcache_flush>:
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
1002174c:	2145883a 	add	r2,r4,r5
10021750:	2007883a 	mov	r3,r4

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
10021754:	2080032e 	bgeu	r4,r2,10021764 <alt_dcache_flush+0x18>
  { 
    ALT_FLUSH_DATA(i); 
10021758:	1800001b 	flushda	0(r3)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
1002175c:	18c00804 	addi	r3,r3,32
10021760:	18bffd36 	bltu	r3,r2,10021758 <alt_dcache_flush+0xc>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
10021764:	208007cc 	andi	r2,r4,31
10021768:	10000126 	beq	r2,zero,10021770 <alt_dcache_flush+0x24>
  {
    ALT_FLUSH_DATA(i);
1002176c:	1800001b 	flushda	0(r3)
10021770:	f800283a 	ret

10021774 <alt_icache_flush>:
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
10021774:	00840004 	movi	r2,4096
10021778:	2007883a 	mov	r3,r4
1002177c:	1140012e 	bgeu	r2,r5,10021784 <alt_icache_flush+0x10>
10021780:	100b883a 	mov	r5,r2
10021784:	194b883a 	add	r5,r3,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
10021788:	1940032e 	bgeu	r3,r5,10021798 <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
1002178c:	1800603a 	flushi	r3
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
10021790:	18c00804 	addi	r3,r3,32
10021794:	197ffd36 	bltu	r3,r5,1002178c <alt_icache_flush+0x18>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
10021798:	208007cc 	andi	r2,r4,31
1002179c:	10000126 	beq	r2,zero,100217a4 <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
100217a0:	1800603a 	flushi	r3
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
100217a4:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
100217a8:	f800283a 	ret

100217ac <atexit>:
100217ac:	200b883a 	mov	r5,r4
100217b0:	000d883a 	mov	r6,zero
100217b4:	0009883a 	mov	r4,zero
100217b8:	000f883a 	mov	r7,zero
100217bc:	002181c1 	jmpi	1002181c <__register_exitproc>

100217c0 <exit>:
100217c0:	defffe04 	addi	sp,sp,-8
100217c4:	dc400015 	stw	r17,0(sp)
100217c8:	000b883a 	mov	r5,zero
100217cc:	2023883a 	mov	r17,r4
100217d0:	dfc00115 	stw	ra,4(sp)
100217d4:	002198c0 	call	1002198c <__call_exitprocs>
100217d8:	8809883a 	mov	r4,r17
100217dc:	0021b480 	call	10021b48 <_exit>

100217e0 <memcmp>:
100217e0:	31ffffc4 	addi	r7,r6,-1
100217e4:	3000061e 	bne	r6,zero,10021800 <memcmp+0x20>
100217e8:	00000a06 	br	10021814 <memcmp+0x34>
100217ec:	39ffffc4 	addi	r7,r7,-1
100217f0:	00bfffc4 	movi	r2,-1
100217f4:	21000044 	addi	r4,r4,1
100217f8:	29400044 	addi	r5,r5,1
100217fc:	38800526 	beq	r7,r2,10021814 <memcmp+0x34>
10021800:	20c00003 	ldbu	r3,0(r4)
10021804:	28800003 	ldbu	r2,0(r5)
10021808:	18bff826 	beq	r3,r2,100217ec <memcmp+0xc>
1002180c:	1885c83a 	sub	r2,r3,r2
10021810:	f800283a 	ret
10021814:	0005883a 	mov	r2,zero
10021818:	f800283a 	ret

1002181c <__register_exitproc>:
1002181c:	defff904 	addi	sp,sp,-28
10021820:	00800034 	movhi	r2,0
10021824:	10806b04 	addi	r2,r2,428
10021828:	dc400115 	stw	r17,4(sp)
1002182c:	14400017 	ldw	r17,0(r2)
10021830:	dc000015 	stw	r16,0(sp)
10021834:	dd400515 	stw	r21,20(sp)
10021838:	8c000c17 	ldw	r16,48(r17)
1002183c:	dd000415 	stw	r20,16(sp)
10021840:	dcc00315 	stw	r19,12(sp)
10021844:	dc800215 	stw	r18,8(sp)
10021848:	dfc00615 	stw	ra,24(sp)
1002184c:	2025883a 	mov	r18,r4
10021850:	282b883a 	mov	r21,r5
10021854:	3029883a 	mov	r20,r6
10021858:	3827883a 	mov	r19,r7
1002185c:	80002626 	beq	r16,zero,100218f8 <__register_exitproc+0xdc>
10021860:	81400117 	ldw	r5,4(r16)
10021864:	008007c4 	movi	r2,31
10021868:	11403716 	blt	r2,r5,10021948 <__register_exitproc+0x12c>
1002186c:	90002026 	beq	r18,zero,100218f0 <__register_exitproc+0xd4>
10021870:	81802217 	ldw	r6,136(r16)
10021874:	30002926 	beq	r6,zero,1002191c <__register_exitproc+0x100>
10021878:	81400117 	ldw	r5,4(r16)
1002187c:	00c00044 	movi	r3,1
10021880:	31004017 	ldw	r4,256(r6)
10021884:	1946983a 	sll	r3,r3,r5
10021888:	2945883a 	add	r2,r5,r5
1002188c:	1085883a 	add	r2,r2,r2
10021890:	1185883a 	add	r2,r2,r6
10021894:	20c8b03a 	or	r4,r4,r3
10021898:	14c02015 	stw	r19,128(r2)
1002189c:	15000015 	stw	r20,0(r2)
100218a0:	00800084 	movi	r2,2
100218a4:	31004015 	stw	r4,256(r6)
100218a8:	90801826 	beq	r18,r2,1002190c <__register_exitproc+0xf0>
100218ac:	2945883a 	add	r2,r5,r5
100218b0:	1085883a 	add	r2,r2,r2
100218b4:	1405883a 	add	r2,r2,r16
100218b8:	28c00044 	addi	r3,r5,1
100218bc:	0009883a 	mov	r4,zero
100218c0:	15400215 	stw	r21,8(r2)
100218c4:	80c00115 	stw	r3,4(r16)
100218c8:	2005883a 	mov	r2,r4
100218cc:	dfc00617 	ldw	ra,24(sp)
100218d0:	dd400517 	ldw	r21,20(sp)
100218d4:	dd000417 	ldw	r20,16(sp)
100218d8:	dcc00317 	ldw	r19,12(sp)
100218dc:	dc800217 	ldw	r18,8(sp)
100218e0:	dc400117 	ldw	r17,4(sp)
100218e4:	dc000017 	ldw	r16,0(sp)
100218e8:	dec00704 	addi	sp,sp,28
100218ec:	f800283a 	ret
100218f0:	81400117 	ldw	r5,4(r16)
100218f4:	003fed06 	br	100218ac <__register_exitproc+0x90>
100218f8:	00800034 	movhi	r2,0
100218fc:	1080ba04 	addi	r2,r2,744
10021900:	1021883a 	mov	r16,r2
10021904:	88800c15 	stw	r2,48(r17)
10021908:	003fd506 	br	10021860 <__register_exitproc+0x44>
1002190c:	30804117 	ldw	r2,260(r6)
10021910:	10c4b03a 	or	r2,r2,r3
10021914:	30804115 	stw	r2,260(r6)
10021918:	003fe406 	br	100218ac <__register_exitproc+0x90>
1002191c:	00800034 	movhi	r2,0
10021920:	10800004 	addi	r2,r2,0
10021924:	10000b26 	beq	r2,zero,10021954 <__register_exitproc+0x138>
10021928:	01004204 	movi	r4,264
1002192c:	103ee83a 	callr	r2
10021930:	10000826 	beq	r2,zero,10021954 <__register_exitproc+0x138>
10021934:	100d883a 	mov	r6,r2
10021938:	10004015 	stw	zero,256(r2)
1002193c:	10004115 	stw	zero,260(r2)
10021940:	80802215 	stw	r2,136(r16)
10021944:	003fcc06 	br	10021878 <__register_exitproc+0x5c>
10021948:	00800034 	movhi	r2,0
1002194c:	10800004 	addi	r2,r2,0
10021950:	1000021e 	bne	r2,zero,1002195c <__register_exitproc+0x140>
10021954:	013fffc4 	movi	r4,-1
10021958:	003fdb06 	br	100218c8 <__register_exitproc+0xac>
1002195c:	01002304 	movi	r4,140
10021960:	103ee83a 	callr	r2
10021964:	1007883a 	mov	r3,r2
10021968:	103ffa26 	beq	r2,zero,10021954 <__register_exitproc+0x138>
1002196c:	88800c17 	ldw	r2,48(r17)
10021970:	1821883a 	mov	r16,r3
10021974:	18000115 	stw	zero,4(r3)
10021978:	18800015 	stw	r2,0(r3)
1002197c:	88c00c15 	stw	r3,48(r17)
10021980:	903fdb26 	beq	r18,zero,100218f0 <__register_exitproc+0xd4>
10021984:	003fba06 	br	10021870 <__register_exitproc+0x54>

10021988 <register_fini>:
10021988:	f800283a 	ret

1002198c <__call_exitprocs>:
1002198c:	defff304 	addi	sp,sp,-52
10021990:	00800034 	movhi	r2,0
10021994:	10806b04 	addi	r2,r2,428
10021998:	df000b15 	stw	fp,44(sp)
1002199c:	17000017 	ldw	fp,0(r2)
100219a0:	00800034 	movhi	r2,0
100219a4:	10800004 	addi	r2,r2,0
100219a8:	1005003a 	cmpeq	r2,r2,zero
100219ac:	d8800215 	stw	r2,8(sp)
100219b0:	e0800c04 	addi	r2,fp,48
100219b4:	dd800915 	stw	r22,36(sp)
100219b8:	dd400815 	stw	r21,32(sp)
100219bc:	dfc00c15 	stw	ra,48(sp)
100219c0:	ddc00a15 	stw	r23,40(sp)
100219c4:	dd000715 	stw	r20,28(sp)
100219c8:	dcc00615 	stw	r19,24(sp)
100219cc:	dc800515 	stw	r18,20(sp)
100219d0:	dc400415 	stw	r17,16(sp)
100219d4:	dc000315 	stw	r16,12(sp)
100219d8:	282d883a 	mov	r22,r5
100219dc:	d9000115 	stw	r4,4(sp)
100219e0:	d8800015 	stw	r2,0(sp)
100219e4:	282b003a 	cmpeq	r21,r5,zero
100219e8:	e4400c17 	ldw	r17,48(fp)
100219ec:	88001226 	beq	r17,zero,10021a38 <__call_exitprocs+0xac>
100219f0:	ddc00017 	ldw	r23,0(sp)
100219f4:	88800117 	ldw	r2,4(r17)
100219f8:	8c802217 	ldw	r18,136(r17)
100219fc:	143fffc4 	addi	r16,r2,-1
10021a00:	80000b16 	blt	r16,zero,10021a30 <__call_exitprocs+0xa4>
10021a04:	9027003a 	cmpeq	r19,r18,zero
10021a08:	a800171e 	bne	r21,zero,10021a68 <__call_exitprocs+0xdc>
10021a0c:	9800051e 	bne	r19,zero,10021a24 <__call_exitprocs+0x98>
10021a10:	8409883a 	add	r4,r16,r16
10021a14:	2105883a 	add	r2,r4,r4
10021a18:	1485883a 	add	r2,r2,r18
10021a1c:	10c02017 	ldw	r3,128(r2)
10021a20:	b0c01226 	beq	r22,r3,10021a6c <__call_exitprocs+0xe0>
10021a24:	843fffc4 	addi	r16,r16,-1
10021a28:	00bfffc4 	movi	r2,-1
10021a2c:	80bff61e 	bne	r16,r2,10021a08 <__call_exitprocs+0x7c>
10021a30:	d8800217 	ldw	r2,8(sp)
10021a34:	10003226 	beq	r2,zero,10021b00 <__call_exitprocs+0x174>
10021a38:	dfc00c17 	ldw	ra,48(sp)
10021a3c:	df000b17 	ldw	fp,44(sp)
10021a40:	ddc00a17 	ldw	r23,40(sp)
10021a44:	dd800917 	ldw	r22,36(sp)
10021a48:	dd400817 	ldw	r21,32(sp)
10021a4c:	dd000717 	ldw	r20,28(sp)
10021a50:	dcc00617 	ldw	r19,24(sp)
10021a54:	dc800517 	ldw	r18,20(sp)
10021a58:	dc400417 	ldw	r17,16(sp)
10021a5c:	dc000317 	ldw	r16,12(sp)
10021a60:	dec00d04 	addi	sp,sp,52
10021a64:	f800283a 	ret
10021a68:	8409883a 	add	r4,r16,r16
10021a6c:	88c00117 	ldw	r3,4(r17)
10021a70:	2105883a 	add	r2,r4,r4
10021a74:	1445883a 	add	r2,r2,r17
10021a78:	18ffffc4 	addi	r3,r3,-1
10021a7c:	11800217 	ldw	r6,8(r2)
10021a80:	1c001826 	beq	r3,r16,10021ae4 <__call_exitprocs+0x158>
10021a84:	10000215 	stw	zero,8(r2)
10021a88:	303fe626 	beq	r6,zero,10021a24 <__call_exitprocs+0x98>
10021a8c:	8d000117 	ldw	r20,4(r17)
10021a90:	9800121e 	bne	r19,zero,10021adc <__call_exitprocs+0x150>
10021a94:	00c00044 	movi	r3,1
10021a98:	1c06983a 	sll	r3,r3,r16
10021a9c:	90804017 	ldw	r2,256(r18)
10021aa0:	1884703a 	and	r2,r3,r2
10021aa4:	10000d26 	beq	r2,zero,10021adc <__call_exitprocs+0x150>
10021aa8:	90804117 	ldw	r2,260(r18)
10021aac:	1884703a 	and	r2,r3,r2
10021ab0:	10000e1e 	bne	r2,zero,10021aec <__call_exitprocs+0x160>
10021ab4:	2105883a 	add	r2,r4,r4
10021ab8:	1485883a 	add	r2,r2,r18
10021abc:	11400017 	ldw	r5,0(r2)
10021ac0:	d9000117 	ldw	r4,4(sp)
10021ac4:	303ee83a 	callr	r6
10021ac8:	88800117 	ldw	r2,4(r17)
10021acc:	a0bfc61e 	bne	r20,r2,100219e8 <__call_exitprocs+0x5c>
10021ad0:	b8800017 	ldw	r2,0(r23)
10021ad4:	147fd326 	beq	r2,r17,10021a24 <__call_exitprocs+0x98>
10021ad8:	003fc306 	br	100219e8 <__call_exitprocs+0x5c>
10021adc:	303ee83a 	callr	r6
10021ae0:	003ff906 	br	10021ac8 <__call_exitprocs+0x13c>
10021ae4:	8c000115 	stw	r16,4(r17)
10021ae8:	003fe706 	br	10021a88 <__call_exitprocs+0xfc>
10021aec:	2105883a 	add	r2,r4,r4
10021af0:	1485883a 	add	r2,r2,r18
10021af4:	11000017 	ldw	r4,0(r2)
10021af8:	303ee83a 	callr	r6
10021afc:	003ff206 	br	10021ac8 <__call_exitprocs+0x13c>
10021b00:	88800117 	ldw	r2,4(r17)
10021b04:	10000b1e 	bne	r2,zero,10021b34 <__call_exitprocs+0x1a8>
10021b08:	89000017 	ldw	r4,0(r17)
10021b0c:	20000a26 	beq	r4,zero,10021b38 <__call_exitprocs+0x1ac>
10021b10:	b9000015 	stw	r4,0(r23)
10021b14:	90000226 	beq	r18,zero,10021b20 <__call_exitprocs+0x194>
10021b18:	9009883a 	mov	r4,r18
10021b1c:	00000000 	call	10000000 <__alt_data_end>
10021b20:	8809883a 	mov	r4,r17
10021b24:	00000000 	call	10000000 <__alt_data_end>
10021b28:	bc400017 	ldw	r17,0(r23)
10021b2c:	883fb11e 	bne	r17,zero,100219f4 <__call_exitprocs+0x68>
10021b30:	003fc106 	br	10021a38 <__call_exitprocs+0xac>
10021b34:	89000017 	ldw	r4,0(r17)
10021b38:	882f883a 	mov	r23,r17
10021b3c:	2023883a 	mov	r17,r4
10021b40:	883fac1e 	bne	r17,zero,100219f4 <__call_exitprocs+0x68>
10021b44:	003fbc06 	br	10021a38 <__call_exitprocs+0xac>

10021b48 <_exit>:
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
10021b48:	20000226 	beq	r4,zero,10021b54 <_exit+0xc>
    ALT_SIM_FAIL();
10021b4c:	002af070 	cmpltui	zero,zero,43969
10021b50:	003fff06 	br	10021b50 <_exit+0x8>
  } else {
    ALT_SIM_PASS();
10021b54:	002af0b0 	cmpltui	zero,zero,43970
10021b58:	003ffd06 	br	10021b50 <_exit+0x8>
10021b5c:	10021988 	cmpgei	zero,r2,2150
